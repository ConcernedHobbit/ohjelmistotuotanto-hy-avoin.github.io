<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Osa 2</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/osa2/">
  <link rel="alternate" type="application/rss+xml" title="Ohjelmistotuotanto avoin yliopisto 2021" href="/feed.xml">

  
</head>


  <body>
    
    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">Ohjelmistotuotanto avoin yliopisto 2021</a>
    
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
            <a class="page-link" href="/osa0/">Osa 0</a>
            
          
            
            
            <a class="page-link" href="/osa1/">Osa 1</a>
            
          
            
            
            <a class="page-link" href="/osa2/">Osa 2</a>
            
          
            
            
            <a class="page-link" href="/osa3/">Osa 3</a>
            
          
            
            
            <a class="page-link" href="/osa4/">Osa 4</a>
            
          
            
            
          
            
            
            <a class="page-link" href="/osa5/">Osa 5</a>
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
            <a class="page-link" href="/tehtavat/">Tehtävät</a>
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
          
        </div>
      </nav>
    

    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Ohjelmistojen vaatimusmäärittely, tuotteen ja sprintin hallinta</h1>
  </header>

  <div class="post-content">
    <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
  <img alt="Creative Commons -lisenssi" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" />
</a></p>

<p>Viikon aiheena on ohjelmistojen vaatimusmäärittely, erityisesti ketterien menetelmien näkökulma vaatimusmäärittelyyn. Käsittelemme myös hieman tuotteen hallintaa sekä koko projektin tasolla että sprintin aikana.</p>

<h2 id="typoja-materiaalissa">Typoja materiaalissa</h2>

<p>Tee <a href="/osa0#typoja-materiaalissa">korjausehdotus</a> editoimalla <a href="https://github.com/ohjelmistotuotanto-hy-avoin/ohjelmistotuotanto-hy-avoin.github.io/blob/master/osa2.md">tätä</a> tiedostoa GitHubissa.</p>

<h2 id="vaatimusmäärittely">Vaatimusmäärittely</h2>

<p>Ehkä keskeisin ongelma ohjelmistotuotantoprosessissa on määritellä <em>asiakkaan vaatimukset</em> (engl. requirements) rakennettavalle ohjelmistolle.</p>

<p>Ohjelmistojen vaatimusten ajatellaan jakaantuvat kahteen luokkaan. <em>Toiminnallisilla vaatimuksilla</em> (engl. functional requirements) tarkoitetaan kaikkia niitä asioita mitä ohjelmistolla voi tehdä, eli ohjelmiston tarjoamia toimintoja. Toinen luokka ovat <em>ei-toiminnalliset vaatimukset</em> (nonfunctional requirements), näitä ovat koko ohjelmistoa koskevat “laatuvaatimukset” (kuten käytettävyys ja tietoturva) ja ohjelmiston toimintaympäristön sille asettamat rajoitteet.</p>

<p>Vaatimusten selvittämistä, dokumentoimista ja hallinnointia kutsutaan
<em>vaatimusmäärittelyksi</em> (engl. requirements engineering). Käytettävästä prosessimallista riippumatta vaatimusmäärittelyn tulee ainakin alkaa ennen ohjelmiston suunnittelua ja toteuttamista.</p>

<p>Lineaarisissa prosessimalleissa, eli vesiputousmallissa vaatimusmäärittely tehdään kokonaisuudessaan ennen ohjelmiston suunnittelua ja toteutusta. Iteratiivisessa ohjelmistokehityksessä vaatimusmäärittelyä taas tapahtuu vähän kerrassaan ohjelmiston toiminnallisuuden kasvamisen myötä.</p>

<h2 id="vaatimusmäärittelyn-vaiheet">Vaatimusmäärittelyn vaiheet</h2>

<p>Vaatimusmäärittelyn luonne vaihtelee paljon riippuen kehitettävästä ohjelmistosta, kehittäjäorganisaatiosta ja ohjelmistokehitykseen käytettävästä prosessimallista. Joka tapauksessa loppukäyttäjän, asiakkaan tai asiakkaan edustajan on oltava prosessissa aktiivisesti mukana.</p>

<p>Vaatimusmäärittely jaotellaan yleensä muutamaan työvaiheeseen:</p>
<ul>
  <li>vaatimusten kartoitus (engl. elicitation)</li>
  <li>vaatimusten analyysi</li>
  <li>vaatimusten validointi</li>
  <li>vaatimusten dokumentointi</li>
  <li>vaatimusten hallinnointi</li>
</ul>

<p>Useimmiten nämä työvaiheet limittyvät ja vaatimusmäärittely etenee spiraalimaisesti tarkentuen, eli ensin kartoitetaan, analysoidaan ja dokumentoidaan osa vaatimuksista. Prosessia jatketaan, kunnes haluttu määrä vaatimuksia on saatu dokumentoitua tarvittavalla tarkkuudella.</p>

<h3 id="vaatimusten-kartoituksen-menetelmiä">Vaatimusten kartoituksen menetelmiä</h3>

<p>Vaatimusmäärittelyn aluksi on syytä selvittää järjestelmän <em>sidosryhmät</em> (engl. stakeholders) eli ne tahot, jotka ovat suoraan tai epäsuorasti tekemisissä järjestelmän kanssa. Tällaisia ovat luonnollisesti ohjelmiston aiotut loppukäyttäjät, tilaavan yrityksen päätösvaltaiset edustajat sekä esim. tarpeen tullen niiden tahojen edustajat, jotka ovat vastuussa tietojärjestelmistä, joiden kanssa määritteltävä ohjelmisto integroituu.</p>

<p>Kun eri sidosryhmät on kartoitettu, käytetään “kaikki mahdolliset keinot” vaatimusten esiin kaivamiseen, esim.:</p>
<ul>
  <li>haastatellaan sidosryhmien edustajia</li>
  <li>pidetään brainstormaussessioita asiakkaan ja sovelluskehitystiimin kesken</li>
</ul>

<p>Alustavien keskustelujen jälkeen kehittäjätiimi voi yhdessä sidosryhmien edustajien kesken strukturoida vaatimusten kartoitusta. Usein mietitään, mitä erilaisia <em>käyttäjärooleja</em>  sovelluksella on, ja keksitään eri käyttäjärooleille tyypillisiä sovelluksen käyttöskenaarioita.</p>

<p>Sovelluksesta kannattaa myös tehdä käyttöliittymäluonnoksia ja paperiprototyyppejä. Skenaarioita ja prototyyppejä tarkastelemalla ja läpikäymällä asiakas voi edelleen tarkentaa näkemystään vaatimuksista.</p>

<p>Jos kehitettävän sovelluksen on tarkoitus korvata olemassa oleva järjestelmä, voidaan vaatimuksia selvittää myös havainnoimalla loppukäyttäjän työskentelyä, tästä menetelmästä käytetään nimitystä <em>etnografia</em>.</p>

<p>Jos uuden sovelluksen on tarkoitus korvata olemassa oleva työskentelyprosessi, esimerkiksi tilanvarausjärjestelmä, on usein hyödyllistä tarkastella myös itse työskentelyprosessia ja koittaa miettiä sen suoraviivaistamista. Ei nimittäin ole useinkaan mielekästä toisintaa vanhaa, ehkä kankeaakin työskentelyprosessia sellaisenaan uuteen sovellukseen.</p>

<h3 id="vaatimusten-analysointi-dokumentointi-ja-validointi">Vaatimusten analysointi, dokumentointi ja validointi</h3>

<p>Vaatimusten keräämisen lisäksi vaatimuksia täytyy <em>analysoida</em>. Onko vaatimuksissa keskinäisiä ristiriitoja ja ovatko ne riittävän kattavat, eli ottavatko ne huomioon kaikki mahdolliset käyttöskenaariot. On myös oleellista varmistaa, että vaatimusten toteutuminen on ylipäätään mahdollista ja taloudellisesti järkevää.</p>

<p>Usein on myös hyvä varmistaa, että vaatimus on <em>todennettavissa</em>, eli että valmiista järjestelmästä pystytään ylipäätään toteamaan noudattaako järjestelmä tätä vaatimusta. Esim. vaatimus <em>järjestelmä on helppokäyttöinen</em> ei ole sikäli hyvä, että helppokäyttöisyyden testaaminen on vaikeaa. Käytettävyyteenkin liittyviä vaatimuksia on mahdollista määritellä <a href="http://www.pcuf.fi/sytyke/lehti/kirj/st20093/ST093-18A.pdf">todennettavalla tavalla</a>.</p>

<p>Kartoitetut vaatimukset on myös pakko <em>dokumentoida</em> muodossa tai toisessa. Ennen koodaamaan ryhtymistä sovelluskehittäjä tarvitsee “speksin”, eli kuvauksen siitä miten sovelluksen tai sen osan tulee toimia. Myös testaamista varten tarvitaan kuvaus sille, miten testattavan ohjelman halutaan toimivan.</p>

<p>Erityisesti vesiputousmallia käyttäessä vaatimusdokumentti toimii oleellisena osana asiakkaan ja ohjelmiston kehittäjien välisessä sopimuksessa. Sovelluksen hinta perustuu vaatimusmäärittelyssä kuvattuun toiminnallisuuteen, ja jos asiakas muuttaakin mieltään, saattaa siitä tulla lisäkustannuksia.</p>

<p>Vaatimukset on myös oleellista <em>validoida</em>, eli tulee varmistaa, että kerätyt ja dokumentoidut vaatimukset todellakin vastaavat asiakkaan mielipidettä, että ne kuvaavat sellaiset järjestelmät mitä asiakas kokee tarvitsevansa.</p>

<p>Vaatimuksia on myös tavalla tai toisella <em>hallinnoitava</em>, erityisesti jos vaatimukset muuttuvat kesken sovelluskehitysprosessin. Hallinnoinnilla siis tarkoitetaan esimerkiksi uusien asiakkaalle mieleen tulevien vaatimusten kirjaamista, jo kirjattujen vaatimusten muokkaamista ym…</p>

<p>Vaatimusmäärittelyprosessin luonne, eli miten vaatimukset kerätään, analysoidaan, dokumentoidaan, validoidaan ja miten niitä hallinnoidaan, vaihtelee siis paljon ohjelmistoprojektin luonteesta riippuen. Palaamme jatkossa vielä hieman tarkemmin eräisiin vaatimusmäärittelyn osa-alueisiin.</p>

<h3 id="toiminnalliset-vaatimukset">Toiminnalliset vaatimukset</h3>

<p>Kuten mainittiin, vaatimukset jakaantuvat kahteen kategoriaan, <em>toiminnallisiin</em> ja <em>ei-toiminnallisiin</em> vaatimuksiin.</p>

<p>Toiminnalliset vaatimukset (engl. functional requirements) kuvaavat mitä järjestelmällä voi tehdä, eli mitä toimintoja siinä on.</p>

<p>Esimerkiksi verkkokaupan toiminnallisia vaatimuksia voisivat olla seuraavat:</p>
<ul>
  <li>asiakas voi rekisteröityä verkkokaupan käyttäjäksi</li>
  <li>rekisteröitynyt asiakas voi lisätä tuotteen ostoskoriin</li>
  <li>onnistuneen luottokorttimaksun yhteydessä asiakkaalle vahvistetaan ostotapahtuman onnistuminen sähköpostitse</li>
  <li>järjestelmään kirjautunut asiakas näkee oman ostoshistoriansa</li>
  <li>ylläpitäjä voi lisätä valikoimaan uusia tuotteita kaupan inventaarioon</li>
  <li>tavarantoimittaja voi päivittää järjestelmässä olevien tuotteiden hintatietoja</li>
</ul>

<p>Toiminnallisten vaatimusten dokumentointi voi tapahtua esim. “feature-listoina” kuten kurssilla Ohjelmistotekniikka on tehty jo parin vuoden ajan tai UML-käyttötapauksina, joita kurssi Ohjelmistotekniikka käytti noin vuoteen 2017 asti. Ketterissä menetelmissä vaatimukset dokumentoidaan usein <em>user storyina</em>, joihin tutustumme kohta tarkemmin.</p>

<p>Riippumatta toiminnallisten vaatimusten dokumentointitavasta on melko yleistä, että vaatimukset ilmaistaan muodossa, jossa kerrotaan jonkin käyttäjäroolin yksittäinen järjestelmän käyttöskenaario.</p>

<p>Esim. <em>tavarantoimittaja voi päivittää järjestelmässä olevien tuotteiden hintatietoja</em> kertoo erään järjestelmän toiminnallisuuden roolin <em>tavarantoimittaja</em> omaaville käyttäjille.</p>

<h3 id="ei-toiminnalliset-vaatimukset">Ei-toiminnalliset vaatimukset</h3>

<p>Vaatimusten toinen luokka, ei-toiminnalliset vaatimukset (engl. nonfunctional requirements), 
jakautuu kahteen osa-alueeseen: laatuvaatimuksiin ja toimintaympäristön rajoitteisiin.</p>

<p><em>Laatuvaatimukset</em> (engl. quality attributes) ovat koko järjestelmän toiminnallisuutta ohjaavia ja rajoittavia tekijöitä, esim.</p>
<ul>
  <li>käytettävyys: minkälainen sovelluksen käyttökokemus on</li>
  <li>tietoturva: kenellä on pääsy järjestelmään ja siinä käsiteltävään dataan</li>
  <li>suorituskyky: miten nopeasti sovellus reagoi erilaisiin käyttäjän syötteisiin</li>
  <li>skaalautuvuus: pysyykö sovellus responsiivisena, eli riittävän nopeasti toimivana käyttäjäkuorman tai käsiteltävän datan määrän kasvaessa</li>
  <li>stabiilius: toipuuko järjestelmä erilaisista virhetilanteista</li>
</ul>

<p>Kaikki laatuvaatimukset eivät ole suoraan järjestelmän käyttäjän havaittavissa, tällaisia ovat esimerkiksi</p>
<ul>
  <li>laajennettavuus: onko sovelluksen toiminnallisuutta helppo kasvattaa jatkossa</li>
  <li>testattavuus: onko sovelluksen virheettömyys varmistettavissa helposti jatkokehityksen yhteydessä</li>
</ul>

<p>On olemassa suuri määrä erilaisia kategorioita laatuvaatimuksille, esim. <a href="http://en.wikipedia.org/wiki/List_of_system_quality_attributes">Wikipedia</a> listaa niitä suuret määrät.</p>

<p>Toimintaympäristön rajoitteita (constraints) ovat muun muassa</p>
<ul>
  <li>toteutusteknologia: millä ohjelmointikielillä ja kirjastoilla sovellus toteutetaan, mitä tietokantoja käytetään</li>
  <li>käyttöympäristö: käytetäänkö sovellusta selaimella vai onko se desktop- tai mobiilisovellus</li>
  <li>integroituminen muihin järjestelmiin: käytetäänkö esim. jonkin ulkoisen palvelun käyttäjätunnusta kirjautumiseen tai jotain avoimien rajapintojen tarjoamaa dataa</li>
  <li>mukautuminen lakeihin ja standardeihin: eräs esimerkki tällaisesta on EU:n tietosuoja-asetus GDPR:n asettamat vaatimukset</li>
</ul>

<p>Toisin kuin toiminnalliset vaatimukset, jotka kuvaavat usein järjestelmän “yksittäisiä featureita” (esim. tuotteen voi lisätä ostoskoriin), ei-toiminnalliset vaatimukset koskevat useimmiten koko järjestelmää, ja vaikuttavat siihen miten järjestelmän perusrakenne eli arkkitehtuuri tulee suunnitella. Esim. jos halutaan rakentaa verkkokauppa, joka skaalautuu miljoonille käyttäjille, tulee se perusteistaan asti rakentaa aivan erilaisella tavalla kuin verkkokauppa, jolla voi olla yhtä aikaa maksimissaan parikymmentä käyttäjää. Jos laatuvaatimukset muuttuvat ohjelmiston kehitystyön edetessä radikaalilla tavalla, muutosten tekeminen saattaa joskus olla vaikeaa ja vaatia isompaa remonttia koko sovelluksen rakennusperiaatteissa.</p>

<h2 id="vaatimusmäärittely-1900-luvulla-eli-vesiputousmallin-valtakaudella">Vaatimusmäärittely 1900-luvulla eli vesiputousmallin valtakaudella</h2>

<p>Vesiputousmallin hengen mukaista oli, että vaatimusmäärittelyä pidettiin erillisenä tuotantoprosessin vaiheena, joka on tehtävä kokonaisuudessaan ennen suunnittelun aloittamista. Ideana oli että suunnittelun ei pidä vaikuttaa vaatimuksiin ja vastaavasti vaatimukset eivät saa rajoittaa tarpeettomasti suunnittelua.</p>

<p>Asiantuntijat korostivat, että vaatimusten dokumentaation on oltava kattava ja ristiriidaton.
Pidettiin siis ehdottoman tärkeänä että heti alussa kerätään ja dokumentoidaan kaikki asiakkaan vaatimukset. Oli jopa suuntauksia, joissa vaatimukset haluttiin luonnollisen kielen sijaan ilmaista formaalilla kielellä eli matemaattisesti jotta esim. ristiriidattomuuden osoittaminen olisi mahdollista.</p>

<p>Tiedetään nimittäin että jos määrittelyvaiheessa tehdään virhe, joka huomataan vasta myöhemmin sovelluskehityksen aikana, esimerkiksi vasta sovellusta testatessa, on muutoksen tekeminen erittäin kallista. Tästä loogisena johtopäätöksenä oli tehdä vaatimusmäärittelystä erittäin järeä ja huolella tehty työvaihe. Ja koska vaatimusmäärittelyä ja sovelluskehitystä hoitivat eri ihmiset, tuli kaikki dokumentoida hyvin tarkalla tasolla.</p>

<h2 id="vaatimusmäärittely-1900-luvulla--ei-toimi">Vaatimusmäärittely 1900-luvulla – ei toimi</h2>

<p>Kuten <a href="/osa1#vesiputousmallin-ongelmia">osassa 1</a> jo todettiin, ideaali jonka mukaan vaatimusmäärittely voidaan irrottaa kokonaan erilliseksi, huolellisesti tehtäväksi vaiheeksi, on osoittautunut utopiaksi.</p>

<p>On useita syitä, jotka johtavat siihen että vaatimusten muuttuminen on lähes väistämätöntä. Ohjelmistoja käyttävien organisaatioiden toimintaympäristö muuttuu nopeasti, mikä on relevanttia tänään, ei ole välttämättä sitä enää 3 kuukauden päästä. Asiakkaiden on mahdotonta ilmaista tyhjentävästi tarpeitaan etukäteen, ja vaikka asiakas osaisikin määritellä kaiken etukäteen, tulee mielipide suurella todennäköisyydellä muuttumaan, kun asiakas näkee lopputuloksen.</p>

<p>Ongelmia aiheuttaa myös se, että huolimatta huolellisesta vaatimusmäärittelystä, ohjelmistokehittäjät eivät osaa tulkita kirjattuja vaatimuksia siten kuin vaatimukset kertonut asiakas tai loppukäyttäjä on tarkoittanut. Jos kehittäjien ja käyttäjien välillä ei ole suoraa kommunikaatiota, väärinymmärrysten syntyminen on erittäin todennäköistä.</p>

<p>Vaatimusmäärittelyä ei myöskään ole mahdollista tai järkevää irrottaa kokonaan suunnittelusta. Suunnittelu auttaa ymmärtämään ongelma-aluetta syvällisemmin ja se taas generoi usein muutoksia vaatimuksiin.</p>

<p>Ohjelmia tehdään enenevissä määrin valmiiden komponenttien, esim. open source -koodin tai verkossa olevien SaaS-palveluiden varaan, ja tämäkin on oleellista ottaa huomioon vaatimusmäärittelyssä.</p>

<p>Jos suunnittelu ja toteutustason asiat otetaan huomioon vaatimusmäärittelyssä, on vaatimusten muotoilu ja priorisointikin helpompaa: näin on mahdollista edes jollain tavalla arvioida vaatimusten toteuttamisen hintaa.</p>

<p>Ilman suunnittelun ja toteutuksen huomioimista riskinä on, että asiakas haluaa vaatimuksen sellaisessa muodossa, joka moninkertaistaa toteutuksen hinnan verrattuna periaatteessa asiakkaan kannalta yhtä hyvään, mutta hieman eri tavalla muotoiltuun vaatimukseen.</p>

<h2 id="vaatimusmäärittely-2000-luvulla">Vaatimusmäärittely 2000-luvulla</h2>

<p>2000-luvun iteratiivisen ja ketterän ohjelmistokehityksen tapa on integroida kaikki ohjelmistotuotannon vaiheet yhteen. Ohjelmistoprojektit toki aloitetaan edelleenkin vaatimusmäärittelyllä, mutta alustava vaatimusmäärittely on vasta suuntaa antava ja sitä on tehty tarkemmin ainoastaan yhden tai muutaman ensimmäisen iteraation tarpeiden verran.</p>

<p>Ketterän vaatimusmäärittelyn hengen mukaista on, että asiakas (Scrumia käytettäessä product owner) priorisoi vaatimukset siten, että kuhunkin iteraatioon valitaan toteutettavaksi ne vaatimukset, jotka tuovat asiakkaalle mahdollisimman paljon liiketoiminnallista arvoa. Ohjelmistokehittäjät arvioivat vaatimusten toteuttamiseen tarvittavaa työmäärää, ja päättävät sen kuinka paljon he voivat ottaa kuhunkin iteraatioon toteutettavia vaatimuksia.</p>

<p>Jokaisen iteraation aikana tehdään määrittelyä, suunnittelua, ohjelmointia ja testausta siinä määrin kuin tarve vaatii. Vaatimusmäärittelykin siis tarkentuu projektin kuluessa. Jokaisen iteraation on tarkoitus saada aikaan valmiita lisätoiminnallisuuksia kehitettävään sovellukseen. Jokaisen iteraation tuotos toimiikin syötteenä seuraavan iteraation vaatimusten määrittelyyn.</p>

<p>Ohjelmiston kasvaessa iteratiivisesti ja inkrementaalisesti pala palalta mahdollistaakin sen, että sovellus voidaan viedä tuotantokäyttöön eli todellisten käyttäjien käytettäväksi jo ennen sovelluksen valmistumista.</p>

<p>Tällä on monia etuja. Sovellus voi ruveta tuottamaan rahallista arvoa jo ennen sovelluskehitysprojektin päättymistä, ja todellisilta käyttäjiltä saatavan palautteen avulla vaatimusmäärittelyn ja sovelluksen jatkokehityksen suuntaa on vielä mahdollista tarkentaa.</p>

<p>Kattavana teemana ketterässä ohjelmistotuotannossa ja siihen liittyvässä vaatimusmäärittelyssä onkin kaikin mahdollisin tavoin tuottaa asiakkaalle maksimaalisesti arvoa.</p>

<h2 id="vaatimusmäärittely-2010-luvulla">Vaatimusmäärittely 2010-luvulla</h2>

<p>Eric Riesin vuonna 2011 julkaisema kirja <a href="http://theleanstartup.com/">The Lean startup</a> kuvaa/formalisoi systemaattisen tavan kartoittaa vaatimuksia erityisen epävarmoissa konteksteissa, kuten startup-yrityksissä.</p>

<p>Malli perustuu kolmiosaisen build-measure-learn-syklin toistamiseen:</p>

<p><img src="http://localhost:4000/images/2-3.png" alt="" height="300px" /></p>

<p>Esim. internetpalveluja tai mobiilisovelluksia rakennettaessa käyttäjien tarpeista, eli järjestelmän vaatimuksista ei ole minkäänlaista varmuutta, voidaan vain tehdä oletuksia siitä mitä ihmiset haluaisivat käyttää. Alkuvaiheessahan järjestelmällä ei edes ole vielä asiakkaita tai käyttäjiä, joiden mielipidettä voitaisiin kysyä.</p>

<p>Periaatteena on ottaa lähtökohdaksi jokin idea siitä, mitä käyttäjät haluavat ja tehdään <em>hypoteesi miten asiakkaat käyttäytyisivät</em>, jos kyseinen järjestelmä/toiminnallisuus/ominaisuusjoukko olisi toteutettu.</p>

<p>Tämän jälkeen rakennetaan nopeasti niin sanottu <em>minimum viable product (MVP)</em>, joka toteuttaa ominaisuuden. Minimum viable productillä ei ole mitään yhtenäistä kaikkien hyväksymää määritelmää, mutta esim. <a href="https://en.wikipedia.org/wiki/Minimum_viable_product">Wikipedia</a> sanoo seuraavasti</p>

<blockquote>
  <p>A minimum viable product (MVP) is a product with just enough features to satisfy early customers and provide feedback for future product development.</p>
</blockquote>

<p>MVP on siis jonkinlainen minimalistinen toteutus ohjelmistosta tai jostain sen uudesta ominaisuudesta, jonka motivaationa on käyttäjäpalautteen kerääminen. MVP ei ole vielä kaikilta osin ohjelmistokehityksen parhaiden käytänteiden mukaan rakennettu ja se on usein ominaisuuksiltaan rajoitettu, sisältäen ainoastaan sen verran toiminnallisuutta kuin hypoteesin mittaamiseen minimissään tarvitaan.</p>

<p>MVP toteutetaan mahdollisimman nopeasti ja laitetaan tuotantokäyttöön oikeille käyttäjille. Tämän jälkeen <em>mitataan</em> miten käyttäjät toimivat MVP:n toteuttaman uuden toiminnallisuuden suhteen. Jos esimerkiksi kyseessä on internetpalvelu, voidaan <em>mitata</em> kuinka moni ihminen löytää palvelun etusivulle, rekisteröityy käyttäjäksi, kirjautuu järjestelmään, kirjautuu vielä viikon jälkeen rekisteröitymisestä ym.</p>

<p>Jos MVP koskee jotain järjestelmään toteutettua uutta ominaisuutta, käytetään usein <em>A/B-testausta</em>: uusi ominaisuus julkaistaan vain osalle käyttäjistä, loput jatkavat vanhan ominaisuuden käyttöä. MVP:n avulla testattava uusi ominaisuus voisi olla esim. verkkokaupan uudenlainen suosittelualgoritmi ja koejärjestelyllä voidaan helposti <em>mitata</em> tuottaako testattava ominaisuus suuremman määrän ostoksia kuin järjestelmän aiempi versio.</p>

<p>Käyttäjien oikeasta järjestelmästä mitattua käyttäytymistä verrataan siis alussa asetettuun hypoteesiin ja näin pystytään <em>oppimaan</em>, olivatko toteutetut vaatimukset järjestelmän käytön suhteen toivottavia, eli käytetäänkö ominaisuuksia, saako niiden avulla hankittua lisää maksavia asiakkaita, sitouttavatko ne käyttäjiä enemmän sovelluksen käyttöön, saavatko ne käyttäjän tuhlaamaan enemmän rahaa ym…</p>

<p>Testattavan idean osoittautuessa käyttökelpoiseksi, tehdään sovellukseen MVP:n sijaan robustimpi toteutus kyseisestä toiminnallisuudesta. Jos taas toteutettu idea ei osoittautunut hyväksi, voidaan palata järjestelmän edelliseen versioon ja jatkaa build-measure-learn-sykliä tekemällä hypoteesi jostain muusta ideasta.</p>

<p>Lean startup -menetelmällä on siis tarkoitus oppia systemaattisesti ja mahdollisimman nopeasti mitä asiakkaat haluavat.</p>

<p>Nimestään huolimatta Lean startup -menetelmää käytetään erityisen paljon isoissa internetpalveluita tuottavissa yhtiöissä, kuten Facebook, Google, Netflix ja Amazon. Myös tietokonepelialalla menetelmä on aktiivisessa käytössä, kun pelien koukuttavuutta yritetään maksimoida.</p>

<h2 id="vaatimusmäärittely-ja-projektisuunnittelu-ketterässä-prosessimallissa">Vaatimusmäärittely ja projektisuunnittelu ketterässä prosessimallissa</h2>

<p>Käydään seuraavaksi läpi yleinen tapa vaatimustenhallintaan ja projektisuunnitteluun ketterässä ohjelmistotuotantoprojektissa.</p>

<p>Tapa pohjautuu Scrumin ja eXtreme Programingin eli XP:n eräiden käytänteiden soveltamiseen.
Lähteenä on monia kirjoja ja blogikirjoituksia, mm. verkosta löytyvät <a href="https://www.infoq.com/minibooks/scrum-xp-from-the-trenches-2/">Henrik Kniberg: Scrum and XP from the trenches</a>, <a href="https://www.jamesshore.com/Agile-Book/">James Shore: Art of Agile development</a> ja <a href="http://scrumbook.org/">Jeff Sutherland ym.:A Scrum book</a> sekä <a href="https://www.mountaingoatsoftware.com/blog">Mike Cohnin</a> loistavat kirjat <em>Agile Estimation and Planning</em> ja <em>User stories applied</em>.</p>

<h2 id="user-story">User story</h2>

<p>Ketterän vaatimusmäärittelyn tärkein työväline on <em>user story</em>. Samasta asiasta käytetään joskus suomenkielistä termiä <em>käyttäjätarina</em>. Käännös ei kuitenkaan ole täysin vakiintunut, joten käytämme jatkossa englanninkielistä termiä.</p>

<p>Alan suurimman auktoriteetin <a href="https://www.mountaingoatsoftware.com/articles/advantages-of-user-stories-for-requirements">Mike Cohnin mukaan</a>:</p>

<blockquote>
  <p>A user story describes functionality that will be valuable to either user or purchaser of software. User stories are composed of three aspects:</p>

  <ol>
    <li>A written description of the story, used for planning and reminder</li>
    <li>Conversations about the story to serve to flesh the details of the
story</li>
    <li>Tests that convey and document details and that will be used to determine that the story is complete</li>
  </ol>
</blockquote>

<p>User storyt siis kuvaavat <em>loppukäyttäjän kannalta arvoa tuottavia toiminnallisuuksia</em>. Jotta näin olisi, kirjoitetaan storyt asiakkaan kannalta ymmärrettävällä kielellä.</p>

<p>Määritelmän alakohtien 1 ja 2 mukaan user story on <em>karkean tason tekstuaalinen kuvaus</em> ja lupaus/muistutus siitä, että toiminnallisuuden <em>tarkka kuvaus on selvitettävä asiakkaan kanssa</em>.</p>

<p>Seuraavat voisivat olla verkkokauppasovelluksen user storyjen kuvauksia (<em>written description</em>):</p>

<ul>
  <li>asiakas voi lisätä tuotteen ostoskoriin</li>
  <li>asiakas voi poistaa ostoskorissa olevan tuotteen</li>
  <li>asiakas voi maksaa luottokortilla ostoskorissa olevat tuotteet</li>
</ul>

<p>User story ei siis ole perinteinen vaatimusmääritelmä, joka ilmaisee tyhjentävästi toiminnallisuuksien vaatimukset; user story on pikemminkin “placeholder” vaatimukselle, eli muistilappu ja lupaus siitä, että toiminnallisuuden vaatimukset tullaan selvittämään riittävällä tasolla ennen kuin user story toteutetaan.</p>

<p>Määritelmän kolmas alikohta sanoo, että Storyyn kuuluu <em>Tests that convey and document details and that will be used to determine that the story is complete</em>. Storyyn siis pitäisi liittyä myös joukko testejä tai kriteereitä, minkä perusteella voidaan katsoa että story on toteutettu.</p>

<p>Se, miten user storyihin liittyvät hyväksymäkriteerit ilmaistaan, vaihtelee hyvin paljon. Parhaassa tapauksessa ne ovat automaattisesti suoritettavissa olevia testejä. Kyseessä voi myös olla lista toimintaskenaarioita, jotka on jollain tavalla kirjattu storyn yhteyteen. Melko tavallista on kuitenkin, että niitä ei kirjata mitenkään, vaan product owner, asiakkaan edustaja tai joku laadunhallinnasta vastaava taho hyväksyy storyn valmiiksi testaamalla manuaalisesti vastaavaa toiminnallisuutta järjestelmästä.</p>

<p>Mike Cohenin kolmiosaisen määritelmän kanssa täsmälleen samansisältöisen mutta hieman eri sanoin muotoillun määritelmän user storyille on antanut <a href="https://ronjeffries.com/xprog/articles/expcardconversationconfirmation/">Ron Jeffries</a>, jonka sanoin user story on <em>card, conversation, confirmation</em> (CCC), eli</p>

<ul>
  <li>card: muistilappumainen usein jopa fyysinen pahvikortti, ei siis missään tapauksessa vesiputousmainen mappiin talletettava laaja vaatimusmäärittelydokumentti</li>
  <li>conversation: jotta storyn voi toteuttaa tarvitaan paljon keskustelua sovelluskehittäjien ja product ownerin, asiakkaiden, loppukäyttäjien ym. välillä, jotta saadaan selville mistä storysta todella on kysymys</li>
  <li>confirmation: kriteerit minkä perusteella voidaan todeta storyn olevan toteutettu valmiiksi</li>
</ul>

<h3 id="esimerkki-user-storysta">Esimerkki user storysta</h3>

<p>Usein on tapana kirjoittaa user storyn kuvaus pienelle noin 10-15 cm pahvikortille tai postit-lapulle. <a href="http://www.agilemodeling.com/artifacts/userStory.htm">Scott Amblerilta</a> lainattu esimerkki</p>

<p><img src="http://localhost:4000/images/2-4.jpg" alt="" /></p>

<p>Kortin etupuolelle on kirjoitettu lyhyt kuvaus storyn sisällöstä, prioriteetti ja estimaatti. 
<em>Estimaatilla</em> tarkoitetaan kortin toiminnallisuuden toteuttamisen työmääräarviota. Palaamme estimointiin pian tarkemmin.</p>

<p>Kortin takapuolella suhteellisen informaalilla kielellä kirjoitettu joukko storyn hyväksymiskriteerejä.</p>

<p>Usein hyväksymiskriteerit kuvaavat joukon erilaisia ehtoja sille, miten storyn kuvaaman 
toiminnallisuuden tulee käyttäytyä eri tilanteissa. Esim. nyt storyn sisältö on <em>As a student I want to purhase a parking pass</em>, eli <em>opiskelija voi ostaa parkkiluvan</em>, hyväksymäkriteerit tarkentavat erilaisia ostamiseen liittyviä ehtoja:</p>

<ul>
  <li>parkkiluvan ostajan on oltava ilmoittautunut läsnäolleeksi</li>
  <li>parkkilupa myönnetään kuukaudeksi kerrallaan</li>
  <li>on mahdollista ostaa vain yksi parkkilupa kuukaudessa</li>
</ul>

<p>Hyväksymäkriteerit ovat tuloksena niistä keskusteluista, joita storyn toiminnallisuuden rajaamisesta käydään product ownerin tai asiakkaan kanssa. Usein ne nimenomaan rajaavat toiminnallisuutta. Esimerkkinä olevan storyn kriteerit jättävät vielä paljon yksityiskohtia auki vaikkapa maksamisen suhteen – miten se tapahtuu? Kriteerejä voisi täydentää seuraavasti</p>

<ul>
  <li>parkkilupa maksetaan käteisellä tai verkkopankissa</li>
  <li>verkkomaksun tapauksessa on käytettävä opiskelijalle henkilökohtaisesti generoitua viitenumeroa</li>
</ul>

<h3 id="hyvän-user-storyn-kriteerit">Hyvän user storyn kriteerit</h3>

<p>Edellinen esimerkki</p>

<blockquote>
  <p>As a student I want to purchase a parking pass so that I can drive to school</p>
</blockquote>

<p>on formuloitu monin paikoin <a href="https://www.agilealliance.org/glossary/user-story-template/">suositussa muodossa</a></p>

<blockquote>
  <p>As a <em>type of user</em>, I want <em>functionality</em> so that <em>business value</em></p>
</blockquote>

<p>Näin muotoilemalla on ajateltu, että user story kiinnittää huomion siihen, kenelle kuvattava järjestelmän toiminto tuottaa arvoa. Muoto ei oikein taivu suomenkielisiin kuvauksiin, joten sitä ei tällä kurssilla käytetä.</p>

<p>Viime aikoina tätä tapaa muotoilla user storyt on myös ruvettu kritisoimaan muun muassa siksi, että kiinnittää liikaa huomioita siihen miten story kirjataan, itse asian eli <em>mistä storyssa on kysymys</em> sijaan. Formaatti onkin menettämässä suosiotaan.</p>

<p><img src="http://localhost:4000/images/2-5.png" alt="" height="200px" /></p>

<p>Bill Wake luettelee artikkelissa <a href="https://xp123.com/articles/invest-in-good-stories-and-smart-tasks/">INVEST in good User Stories</a> kuusi user storyille toivottavaa ominaisuutta:</p>

<ul>
  <li>Independent</li>
  <li>Negotiable</li>
  <li>Valuable</li>
  <li>Estimable</li>
  <li>Small</li>
  <li>Testable</li>
</ul>

<p><em>Valuable</em> tarkoittaa, että storyn tulee kuvata käyttäjälle arvoa tuottavia ominaisuuksia, jotka on muotoiltu käyttäen asiakkaan kieltä, ei teknistä jargonia.</p>

<p>Hyvänä käytäntönä pidetään että user story kuvaa järjestelmän kaikkia osia koskevaa (esim. käyttöliittymä, bisneslogiikka, tietokanta) eli “end to end”-toiminnallisuutta, eikä pelkästään yksittästä järjestelmän teknistä kerrosta koskevaa, käyttäjän kannalta näkymätöntä teknistä ratkaisua.</p>

<p>Esimerkiksi <em>lisää jokaisesta asiakkaasta rivi tietokantatauluun customers</em> ei olisi suositeltava muotoilu user storylle, sillä se ei ole kirjattu käyttäjän kannalta ymmärrettävällä tavalla ja ottaa kantaa ainoastaan tietokantakerrokseen.</p>

<p>Hyvä user story on <em>negotiable</em>, eli se ei ole tyhjentävästi kirjoitettu vaatimusmäärittely vaan lupaus siitä että asiakas ja toteutustiimi sopivat tarvittavalla tarkkuudella storyn toiminnallisuuden sisällön ennen kuin story otetaan toteutettavaksi.</p>

<p><em>Estimatable</em> taas sanoo, että user storyn toteuttamisen vaatima työmäärä pitää olla arvioitavissa kohtuullisella tasolla.</p>

<p>Työmäärän arviointi onnistuu paremmin jos user storyt ovat riittävän pieniä, <em>small</em>. 
User story on ehdottomasti toiminnallisuudeltaan liian iso, jos se ei ole toteutettavissa yhdessä sprintissä. Juuri ja juuri yhdessä sprintissä toteutettavissa oleva story on myöskin huomattavan riskialtis, parempi koko storylle onkin lähempänä yhden päivän kuin vaikkapa viikon vaadittavaa työmäärää.</p>

<p>Liian suuret user storyt tulee jakaa osiin ennen kuin ne otetaan toteutettavaksi. Esimerkiksi verkkokaupassa voisi olla käyttötapaus <em>kaupan ylläpitäjä voi kirjautua sivulle, lisätä ja päivittää tuotteiden tietoja sekä tarkastella asiakkaille tehtyjen toimitusten listaa</em> tulisi ehdottomasti jakaa useaan osaan:</p>
<ul>
  <li>ylläpitäjä voi kirjautua sovellukseen</li>
  <li>ylläpitäjä voi lisätä tuotteita valikoimaan</li>
  <li>ylläpitäjä voi päivittää tuotteiden tietoja</li>
  <li>ylläpitäjä voi tarkastella asiakkaille tehtyjen toimitusten listaa</li>
</ul>

<p>Kuudes toivottu ominaisuus on testattavuus, <em>testability</em>, eli toteutettaviksi valittavien user storyjen tulisi olla sellaisia, että niille on mahdollista tehdä testit tai laatia kriteerit, joiden avulla on mahdollista yksikäsitteisesti todeta, onko story toteutettu hyväksyttävästi. Ei-toiminnalliset vaatimukset (esim. suorituskyky, käytettävyys) aiheuttavat usein haasteita testattavuudelle.</p>

<p>Esimerkiksi verkkokaupan user story <em>kaupan tulee toimia tarpeeksi nopeasti kovassakin kuormituksessa</em> on mahdollista muotoilla testattavaksi esimerkiksi seuraavasti:
<em>käyttäjän vasteaika saa olla korkeintaan 0.5 sekuntia 99% tapauksissa jos yhtäaikaisia käyttäjiä sivulla on maksimissaan 1000</em>.</p>

<p>Kriteerin <em>Independent</em> mukaan user storyjen pitäisi olla toisistaan mahdollisimman riippumattomia eli storyjen kuvaamia toiminnallisuuksia pitäisi pystyä toteuttamaan riippumatta toisten storyjen tilanteesta. Tämä taas antaa product ownerille enemmän vapausasteita storyjen priorisointiin, eli sen määrittelyyn missä järjestyksessä sovelluksen toiminnallisuudet valmistuvat.</p>

<p>On toki tilanteita, joissa storyjen keskinäistä riippuvuutta ei voi välttää, esimerkiksi verkkokaupan storyjen <em>lisää tuote ostoskoriin</em> ja <em>poista tuote ostoskorista</em> tapauksessa.</p>

<p>Kuten tulemme myöhemmin <a href="/osa2#user-story-ja-epiikki">tässä osassa</a> toteamaan, user storyjen ei kannata olla koko aikaa <em>hyvän storyn</em> INVEST-kriteerien mukaista. Kriteeristö koskeekin kokonaisuudessa oikeastaan vain korkean prioriteetin user storyjä eli sellaisia, jotka tullaan toteuttamaan lähitulevaisuudessa. Matalamman prioriteetin storyt voivat aivan hyvin olla vielä isompia ja testattavuudenltaan sekä työmääräarvioiltaan epämääräisempiä. Storyt tulee jakaa ja saattaa INVEST-kriteerien mukaiseksi viimeistään siinä vaiheessa kun story nousee lähemmäs prioriteettijärjestyksen huippua.</p>

<h2 id="alustava-product-backlog">Alustava product backlog</h2>

<p>Edellisellä viikolla Scrumin yhteydessä puhuttiin <em>product backlogista</em>, joka on siis priorisoitu lista asiakkaan tuotteelle asettamista vaatimuksista eli toivotuista ominaisuuksista ja toiminnoista. Nykyään käytäntönä on, että product backlog koostuu nimenomaan user storyistä.</p>

<p>Projektin aluksi kannattaa heti ruveta etsimään ja määrittelemään user storyja ja muodostaa näistä alustava product backlog. Scrumia sovellettaessa tämä tehdään useimmiten ennen ensimmäisen sprintin alkua. Joskus tästä vaiheesta käytetään nimitystä <a href="https://www.mountaingoatsoftware.com/blog/sprint-zero-a-good-idea-or-not">nollasprintti</a>.</p>

<p>Alustavan product backlogin muodostamisessa ovat käytettävissä kaikki yleiset vaatimusten kartoitustekniikat:</p>
<ul>
  <li>haastattelut</li>
  <li>brainstormaus</li>
  <li>workshopit</li>
</ul>

<p>Alustavan user storyjen keräämisvaiheen ei ole tarkoituksenmukaista kestää kovin kauaa, maksimissaan muutaman päivän. User storyjen luonne (muistilappu ja lupaus, että vaatimus tarkennetaan ennen toteutusta) tekee niistä hyvän työkalun projektin aloitukseen. Turhiin detaljeihin ei ole tarkoitus puuttua ja ei edes kannata tavoitella täydellistä ja kattavaa listaa vaatimuksista, sillä storyjä tarkennetaan, muokataan ja luodaan lisää myöhemmin. User storyn määritelmän toinen kohtahan on <em>conversations about the story to serve to flesh the details of the story</em>, ja tämä tarkoittaa sitä että storyn sisältö saattaa elää ajan mittaan.</p>

<p>Kun alustava lista user storyistä on kerätty, ne <em>priorisoidaan</em> ja niiden vaatima <em>työmäärä arvioidaan</em> projektille tarkoituksenmukaisella tasolla. Näin muodostuu alustava product backlog, eli priorisoitu lista vaatimuksista.</p>

<h2 id="backlogin-priorisointi">Backlogin priorisointi</h2>

<p>Product backlog on siis <em>priorisoitu lista user storyjä</em>.</p>

<p>Kuten todettiin <a href="/osa1 #scrum">Scrumin esittelyn yhteydessä</a> priorisoinnista vastaa <em>product owner</em>.  Prioriteetti määrää järjestyksen, missä ohjelmistokehittäjät toteuttavat backlogilla olevia toiminnallisuuksia.</p>

<p>Priorisoinnin motivaationa on pyrkiä maksimoimaan asiakkaan kehitettävästä ohjelmistosta saama hyöty/arvo. Tärkeimmät asiat halutaan toteuttaa mahdollisimman nopeasti ja näin saada tuotteesta alustava versio markkinoille niin pian kuin mahdollista.</p>

<p>User storyjen priorisointiin vaikuttaa storyn kuvaaman toiminnallisuuden asiakkaalle tuovan arvon lisäksi ainakin storyn toteuttamiseen kuluva <em>työmäärä</em> sekä storyn kuvaamaan ominaisuuteen sisältyvä <em>tekninen riski</em>.</p>

<p>Ei ole siis kokonaistaloudellisesti edullista tehdä priorisointia välttämättä pelkästään perustuen asiakkaan user storyistä saamaan arvoon, joku story voi tuottaa paljon arvoa, mutta voi olla toteutukseltaan liian työläs. Parempi <a href="https://fi.wikipedia.org/wiki/Sijoitetun_p%C3%A4%C3%A4oman_tuottoaste">sijoitetun pääoman tuotto eli ROI</a> voidaan saada jollain vaihtoehtoisella storylla, joka on toteutukseltaan vähemmän työläs.</p>

<p>Myös projektiin liittyvät tekniset riskit kannattaa ottaa priorisoinnissa huomioon. Tekninen riski voi olla esim. se, onko jokin ohjelmiston kannalta kriittinen ominaisuus ylipäätään mahdollista toteuttaa tehokkaasti ja taloudellisesti järkevin resurssein. Tällainen riskitekijä kannattaa selvittää mielummin heti kuin vasta siinä vaiheessa, kun projektiin on jo sijoitettu suuri määrä resursseja.</p>

<h2 id="estimointi-eli-työmäärän-arviointi">Estimointi eli työmäärän arviointi</h2>

<p>User storyjen viemän työmäärän arvioimiseen on oikeastaan kaksi motivaatiota:</p>
<ul>
  <li>auttaa asiakasta priorisoinnissa</li>
  <li>mahdollistaa koko projektin tai tiettyjä toiminnallisuuskokonaisuuksia sisältävien versioiden viemän ajan summittainen arviointi</li>
</ul>

<p>Työmäärän arvioimiseen on kehitetty vuosien varrella useita erilaisia menetelmiä. Kaikille yhteistä on se, että ne eivät toimi kunnolla, eli tarkkoja työmääräarvioita on mahdoton antaa. Joskus työmäärän arvioinnista käytetäänkin leikillisesti termiä <em>guestimation</em> koska työmääräarviointi on lopulta useimmiten lähinnä arvailua.</p>

<p>Estimointiin liittyvää epävarmuutta kuvaa käsite <em>cone of uncertainty</em>:</p>

<p><img src="http://localhost:4000/images/2-6.png" alt="" height="400px" /></p>

<p>Eli mitä kauempana tuotteen/ominaisuuden valmistuminen on, sitä epätarkempia työmääräarviot ovat. Tämä taas johtuu siitä, että tuntemattomien epävarmuustekijöiden määrä alussa on suuri, mutta kun tuotteen rakentamisessa ollaan pidemmällä, ymmärrys kasvaa ja työmäärienkin arviointi alkaa olla realistisempaa. Jos esim. mietitään user storya <em>tuotteen voi poistaa ostoskorista</em>, on järjestelmän alustavassa määrittelyvaiheessa todella vaikea antaa minkäänlaista työmääräarviota storylle. Kun sovelluskehitys etenee ja tiedetään miten ostoskori teknisesti toteutetaan, minkälainen sovelluksen käyttöliittymä on jne, muuttuu tuotteen ostoskorista poistamista koskevan storyn työmääräarvion tekeminen jo huomattavasti helpommaksi.</p>

<h2 id="suhteelliseen-kokoon-perustuva-estimointi">Suhteelliseen kokoon perustuva estimointi</h2>

<p>Ketterät ohjelmistotuotantomenetelmät ottavat itsestäänselvyytenä sen, että estimointi on epävarmaa ja tarkentuu vasta projektin kuluessa. Koska näin on, pyritään vahvoja estimointiin perustuvia lupauksia ohjelmiston valmistumisaikatauluista välttämään.</p>

<p>On olemassa jonkin verran evidenssiä (ks <a href="https://www.mountaingoatsoftware.com/books/agile-estimating-and-planning">Cohn: Agile estimation and planning</a>, luku 8) siitä, että vaikka ominaisuuksien toteuttamiseen menevän tarkan ajan arvioiminen on vaikeaa, osaavat ohjelmistokehittäjät jossain määrin arvioida eri tehtävien vaatimaa työmäärää suhteessa toisiinsa.</p>

<p>Esimerkkejä tällaisestä suhteellisesta estimoinnista ovat</p>
<ul>
  <li>user storyn <em>tuotteen lisääminen ostoskoriin toteuttaminen</em> vie yhtä kauan kuin user storyn <em>tuotteen poistaminen ostoskorista toteuttaminen</em></li>
  <li>user storyn <em>ostoskorissa olevien tuotteiden maksaminen luottokortilla</em> toteuttaminen taas vie noin kolme kertaa kauemmin kun edelliset</li>
</ul>

<p>Ketterissä menetelmissä käytetäänkin yleisesti suhteelliseen kokoon perustuvaa estimointia, joissa usein arvioinnin yksikkönä käytetään abstraktia aikamäärettä <em>story point</em>, joka ei välttämättä vastaa mitään todellista aikamäärettä.</p>

<p>Verkkokaupan tapauksessa voitaisiinkin määrittää, että user storyn <em>tuotteen lisääminen ostoskoriin toteuttaminen</em> työmääräarvio on yksi story point. Tällöin <em>tuotteen poistaminen ostoskorista toteuttaminen</em> olisi myös suhteelliselta estimaatiltaan yksi story point ja <em>ostoskorissa olevien tuotteiden maksaminen luottokortilla</em> kolme story pointia.</p>

<h2 id="estimoinnin-suorittaminen">Estimoinnin suorittaminen</h2>

<p>Estimointi tehdään yhteistyössä kehitystiimin ja product ownerin kanssa. Product ownerin roolina on tarkentaa estimoitaviin user storeihin liittyviä vaatimuksia siinä määrin että kehitystiimi ymmärtää tarkasti mistä on kyse. Varsinaisen estimoinnin eli <em>työmääräarvion tekee kuitenkin aina ohjelmistokehitystiimi</em>. Tämä on tärkeää, sillä ainoastaan sovelluskehittäjillä on edes jossain määrin realistisia edellytyksiä arvion tekemiseen.</p>

<p>Kuten edellisellä viikolla mainittiin, määritellään ketterissä projekteissa yleensä <a href="/osa1#definition-of-done">definition of done</a>, eli se yleinen taso mitä valmiilla tarkoitetaan. Useimmiten valmiin määritellään sisältävän user storyn määrittelyn, suunnittelun, toteutuksen, automatisoitujen testien tekemisen, integroinnin muuhun sovellukseen, dokumentoinnin ja joskus jopa tuotantoon viennin.</p>

<p>Estimoinnissa tuleekin arvioida user storyn viemä aika definition of donen tarkkuudella, eikä missään nimessä esim. ottaen huomioon pelkkä ohjelmointiin kuluva aika.</p>

<p>Usein estimointia auttaa user storyn pilkkominen teknisiin työvaiheisiin. Esimerkiksi story <em>tuotteen lisääminen ostoskoriin</em> voisi sisältää toteutuksen kannalta seuraavat tekniset tehtävät (task):</p>
<ul>
  <li>tarvitaan sessio, joka muistaa asiakkaan</li>
  <li>domain-olio ostoskorin ja ostoksen esittämiseen</li>
  <li>laajennus tietokantaskeemaan</li>
  <li>html-näkymää päivitettävä tarvittavilla painikkeilla</li>
  <li>kontrolleri painikkeiden käsittelyyn</li>
  <li>yksikkötestit kontrollerille ja domain-olioille</li>
  <li>hyväksymätestien automatisointi</li>
</ul>

<p>Työvaiheisiin pilkkominen saattaa vaatia myös hieman suunnittelua, esim. täytyy miettiä, miten ohjelman rakennetta on muokattava, jotta uusi toiminnallisuus saadaan järkevästi toteutettua.</p>

<p>Jos kyseessä on samantapainen toiminnallisuus kuin joku aiemmin toteutettu, voi estimointi tapahtua ilman user storyn vaatimien erillisten työvaiheiden miettimistä, suhteuttamalla estimoitava toiminnallisuus aiemmin toteutettuihin storyihin.</p>

<p>Koska estimointi on joka tapauksessa suhteellisen epätarkkaa, estimointiin ei kannata käyttää turhan paljoa aikaa, esim. korkeintaan 15 minuuttia yhden user storya kohti. Jos tämä ei riitä, on todennäköistä että storyn sisältöä, siihen sisältyviä oletuksia ja sen riippuvuutta muusta järjestelmästä ei tunneta vielä sillä tarkkuudella että estimointi olisi mielekästä.</p>

<p>Voi myös olla että vaikeasti estimoitava story muuttuu helpommaksi arvioida jos se jaetaan useammaksi pienemmäksi ja rajatumman toiminnallisuuden kuvaamaksi storyksi.</p>

<p>User storyn estimointi ei ole kertaluontoinen toimenpide; estimaattia tarkennetaan projektin kuluessa sitä mukaa, kun kehittäjien näkemys eri asioiden toteuttamisperiaatteista alkaa selkiytyä.</p>

<p>Kuten äsken mainittiin, suhteellisessa estimoinnissa käytetty yksikkö <em>story point</em> ei useimmiten vastaa mitään aikamäärettä. Jotkut kuitenkin mitoittavat Story Pointin ainakin projektin alussa <em>ideal working dayn</em> eli työpäivän johon ei sisälly mitään häiriötekijöitä suuruiseksi. Eri tiimien käyttämät story point -yksiköt eivät kuitenkaan ole ollenkaan vertailukelpoisia keskenään.</p>

<p><a href="https://www.atlassian.com/agile/project-management/estimation">Monet</a> <a href="https://medium.com/serious-scrum/12-common-mistakes-made-when-using-story-points-f0bb9212d2f7">tahot</a> suosittelevat olemaan sotkematta story pointeja tunteihin tai päiviin. Eräs argumenteista story pointin ja tarkkojen aikamääreiden sitomattomuuden puolesta on se, että jos tiimi määrittelisi story pointin olevan esimerkiksi 8 tuntia työtä, niin tiimin estimaatit saatettaisiin esim. yrityksen johdossa ajatella sitoumukseksi kunkin työvaiheen tarvitsemasta ajasta. Tämän taas ketterät menetelmät haluavat ehdottomasti välttää estimaattien perimmäisen epävarmuuden takia.</p>

<h2 id="estimoinnin-menetelmiä">Estimoinnin menetelmiä</h2>

<p>Eräs melko suosittu tapa estimoinnille on kiinnittää muutama erikokoinen story referenssiksi ja verrata sitten muiden storyjen vaativuutta näihin:</p>

<p><img src="http://localhost:4000/images/2-7.png" alt="" height="300px" /></p>

<p>Koska estimointi on joka tapauksessa melko epätarkkaa, ei estimoinnissa ole tarkoituksenmukaista käyttää kovin tarkkaa skaalaa. Useimmiten käytetään yläpäästä harvenevaa skaalaa esim. 1, 2, 3, 5, 10, 20, 40, 100.  Myös fibonaccin lukujono 1, 2, 3, 5, 8, 13, 21, 34, 55 on suosiossa estimoinnin skaalana.</p>

<p>Motivaationa yläpäästä harvenevalle skaalalle on se, että koska isojen storyjen estimointiin liittyy erityisen suuri epävarmuus, ei kannata edes teeskennellä että skaala olisi isojen storyjen suhteen kovin tarkka.</p>

<p>Joskus estimoinnissa käytetään arvoa <em>epic</em>, jolla tarkoitetaan niin isoa tai huonosti ymmärrettyä user storyä, että sitä ei ole toistaiseksi mieltä estimoida. Itse asiassa alan suurin auktoriteetti Mike Cohn suosittelee käyttämään skaalaa 1, 2, 3, 5, 8 tai 1, 2, 4, 8 ja antamaan sitä suuremmille storyille estimaatti epic.</p>

<p>Jotta estimaatin <em>epic</em> saaneet storyt tulisivat estimoitua, ne tulee pilkkoa pienempiin, paremmin hallittaviin storyihin. Käsitteellä epic on eräs toinenkin merkitys user storyjen parissa, mihin palaamme hieman myöhemmin.</p>

<p>Hyvänä periaatteena pidetään että kaikki kehitystiimin jäsenet osallistuvat estimointiin. Näin tiimille syntyy yhtenäinen ymmärrys user storyn sisällöstä. Eräs suosittu tapa osallistaa koko tiimi estimointiin on <a href="https://www.crisp.se/bocker-och-produkter/planning-poker">planning poker</a>.</p>

<h3 id="planning-poker">Planning poker</h3>

<p>Planning pokerissa käydään läpi backlogilla olevia user storyja yksi kerrallaan. Product owner esittelee user storyn sisällön ja selittää tarkemmin storyn luonnetta ja vaatimuksia.</p>

<p>Tiimi keskustelee storystä, miettii kenties storyn jakautumista teknisiin työvaiheisiin
Kun kaikki kokevat olevansa valmiina arvioimaan, jokainen kertoo arvionsa (yksikkönä siis story point). Usein tämä vaihe toteutetaan siten, että käytössä on pelikortteja, joilla on estimaattien arvoja, esim 1, 2, 5, 10, … ja kukin estimointiin osallistunut näyttää estimaattinsa yhtä aikaa.</p>

<p>Jos estimaatit ovat suunnilleen samaa tasoa, merkataan estimaatti user storylle ja siirrytään seuraavaan.</p>

<p>Jos ehdotetuissa estimaateissa on paljon eroavaisuuksia, keskustelee tiimi eroavaisuuksien syistä. Voi esimerkiksi olla, että osa tiimin jäsenistä ymmärtää user storyn vaatimukset aivan eri tavalla ja tämä aiheuttaa eroavaisuutta estimaatteihin.</p>

<p>Kun tiimi on keskustellut aikansa, tapahtuu uusi estimointikierros ja riittävä konsensus todennäköisesti saavutetaan pian.</p>

<p><img src="http://localhost:4000/images/2-8.png" alt="" height="350px" /></p>

<h2 id="hyvä-product-backlog-on-deep">Hyvä product backlog on DEEP</h2>

<p>Mike Cohn ja Roman Pichler ovat lanseeranneet lyhenteen
<a href="https://www.romanpichler.com/blog/make-the-product-backlog-deep/">DEEP</a> kuvaamaan hyvän backlogin ominaisuuksia. Lyhenne tulee sanoista <em>detailed appropriately, estimated, emergent</em> ja <em>prioritized</em>.</p>

<p>Näistä ominaisuuksista <em>estimated</em> ja <em>prioritized</em> ovat meille tuttuja: storyillä on työmääräarviot ja storyt on priorisoitu eli asetettu tärkeysjärjestykseen.</p>

<p>Hyvä backlog on myös <em>detailed appropriately</em> eli sopivan detaljoitu. Backlogin prioriteeteiltaan korkeimpien eli pian toteutettavaksi tulevien user storyjen tulee olla suhteellisen pieniä, niiden hyväksymiskriteerit tulee olla suunnilleen selvillä ja vaaditusta työmäärästä pitäisi olla kohtuullisen hyvä kuva.</p>

<p>Alemman prioriteetin user storyt voivat vielä olla isompia ja karkeammin estimoituja. Itse asiassa alemman prioriteetin storyjä ei edes kannata määritellä kovin tarkasti, sillä kestää vielä kauan ennen kuin ne otetaan toteutettavaksi johonkin sprinttiin. Usein käy vieläpä niin, että alemman prioriteetin storyjä ei lopulta toteuteta koskaan, sillä niiden määrittelemä toiminnallisuus havaitaankin tarpeettomaksi. Alhaisen prioriteetin storyihin ei siis todellakaan kannata investoida spekulatiivisesti liikaa aikaa.</p>

<p><em>Emergent</em> kuvaa backlogin <a href="https://www.romanpichler.com/blog/make-the-product-backlog-deep/">muuttuvaa luonnetta</a> :</p>

<blockquote>
  <p>The product backlog has an organic quality. It evolves, and its contents change frequently. New items emerge based on customer and user feedback, and they are added to the product backlog. Existing items are modified, reprioritized, refined, or removed on an ongoing basis.</p>
</blockquote>

<p>Backlog ei siis pysy muuttumattomana vaan elää koko ajan. Uusia storyjä tulee, olemassa olevia storyjä tarkennetaan ja pilkotaan, tarpeettomia storyjä poistetaan. Työmääräarvioita ja prioriteetteja uudelleenmääritellään.</p>

<p>Tämä kaikki ei tietenkään tapahdu itsestään, vaan backlogia tulee aktiivisesti hoitaa (engl. backlog grooming tai backlog refinement) projektin edetessä. <a href="https://scrumguides.org/scrum-guide.html#artifacts-productbacklog">Scrum guide</a> mainitsee että backlogin groomausta tulee tapahtua läpi sprintin yhteistyössä product ownerin ja kehitystiimin kesken.</p>

<p>Ideana on siis pitää backlog koko ajan DEEP-tilassa, joka taas helpottaa oleellisesti ennen jokaista uutta sprinttiä tehtävää sprintin suunnittelua. Jos backlog on huonossa kunnossa (prioriteetit miten sattuu, tärkeät storyt epämääräisessä tilassa, uusia tunnistettuja tarpeita vastaavia storyjä ei ole lisätty backlogille) sprintin suunnittelua tehtäessä, menee kaikkien aikaa hukkaan.</p>

<p><img src="http://localhost:4000/images/2-9.png" alt="" height="250px" /></p>

<h2 id="user-story-ja-epiikki">User story ja epiikki</h2>

<p>Aiemmin mainitsimme, että hyvän user storyn tuntomerkki on, että se noudataa INVEST-kriteeristöä, eli story on <em>independent, negotiable, valuable, small, testable</em>. Eräänä kriteerinä on siis storyn pienuus, user storyn tulee olla toteutettavissa yhdessä sprintissä. Backlokin DEEP-kriteeristö taas sanoo, että backlogin pitää olla <em>sopivan detaljoitu</em>, erityisesti alhaisen prioriteetin storyja ei kannata tehdä liian tarkasti. INVEST-kriteeristö päteekin nimenomaan korkean prioriteetin storyihin, eli ennen kuin story voidaan ottaa toteutettavaksi, tulee sen olla tarpeeksi pieni, hyvin estimoitu ja testattavissa, eli storyn hyväksymiskriteerien tulee olla selkeitä.</p>

<p>Backlogin alaosissa olevat storyt taas voivat olla isoja, jopa sellaisia että niitä ei missään nimessä lopulta pystytä edes toteuttamaan yhdessä sprintissä, vaan ne tulee ennen mahdollista toteuttamista jakaa pienempiin, rajatumpiin storyihin. Tämän kaltaisia isoja storyja nimitetään usein <em>epiikeiksi</em> (engl. epic).</p>

<p>Joissain yhteydessä sanotaan että user storyt ovat <a href="http://scrumbook.org/value-stream/product-backlog/definition-of-ready.html">ready</a>, jos ne noudattavat INVEST-kriteeristöä eli ovat <em>valmiita sprinttiin otettavaksi</em>.</p>

<p>User story on siis elinaikanaan todennäköisesti ensin <em>epic</em>. Kun aikaa kuluu, story ehkä pilkotaan ja joistain sen osista tulee <em>ready</em> kun niitä tarkennetaan prioriteetin noustessa. Kun story on valittu sprinttiin ja se toteutetaan, muuttuu sen tilaksi <em>done</em>. Kaikki backlogille lisättävät storyt eivät toki ole niin isoja että niiden voisi ajatella olevan kokoluokkaa <em>epic</em>, uusi story voi olla pienehkö mutta vaatimuksiltaan selkiytymätön, eli ei vielä <em>ready</em>.</p>

<h2 id="velositeetti">Velositeetti</h2>

<p>User storyjen estimoinnin toinen tarkoitus on, että se mahdollistaa koko projektin tai jonkin sen suuremman kokonaisuuden viemän aikamäärän summittaisen arvioinnin.</p>

<p>Jos estimoinnin yksikkönä kuitenkin on abstrakti käsite <em>story point</em>, miten estimaattien avulla on mahdollista arvioida projektin viemää aikamäärää?</p>

<p>Kehitystiimin <em>velositeetti</em> (engl. velocity) tarjoaa tähän osittaisen ratkaisun. Velositeetilla tarkoitetaan sitä story pointtien määrää, minkä verran tiimi pystyy keskimäärin toteuttamaan yhden sprintin aikana.</p>

<p>Jos tiimin velositeetti on selvillä ja projektissa tai sen jossain kokonaisuudessa toteutettavaksi tarkoitetut user storyt ovat estimoituja, on helppo tehdä alustava arvio vaadittavasta aikamäärästä</p>

<blockquote>
  <p>(user storyjen estimaattien summa) / velositeetti * sprintin pituus</p>
</blockquote>

<p>Projektin alkaessa velositeetti ei yleensä ole selvillä, ellei kyseessä ole jo aiemmin yhdessä työskennellyt tiimi. On kehitetty useita erilaisia tapoja, joiden avulla velositeetti voidaan yrittää ennustaa jo ennen projektin aloittamista. Nämä ovat kuitenkin hyvin epäluotettavia, ja emme käsittele niitä nyt. Projektin alkaessa arviot sen kestosta ovatkin erittäin epätarkkoja, lähinnä pelkkiä arvauksia.</p>

<p>Velositeetti vaihtelee tyypillisesti alussa melko paljon, erityisesti jos sovellusalue ja/tai käytetyt teknologiat eivät ole tiimille täysin tuttuja. Velositeetti kuitenkin alkaa yleensä stabiloitumaan muutaman sprintin jälkeen.</p>

<p><img src="http://localhost:4000/images/2-11.png" alt="" height="350px" /></p>

<p>Tiimin velositeetti ja siihen perustuva projektin tai sen osakokonaisuuden keston arvio alkaakin tarkentumaan pikkuhiljaa.</p>

<p>Ketterissä menetelmissä on oleellista kuvata mahdollisimman realistisesti projektin etenemistä. Tämän takia velositeettiin lasketaan mukaan ainoastaan täysin valmiiksi (eli <a href="/osa1#definition-of-done">definition of donen</a> määrittelemällä laatutasolla) toteutettujen user storyjen story pointit. “Lähes valmiiksi” tehtyä työtä ei siis katsota ollenkaan tehdyksi työksi.</p>

<p><img src="http://localhost:4000/images/2-12.png" alt="" height="250px" /></p>

<h3 id="eri-tiimien-velositeettien-vertailu">Eri tiimien velositeettien vertailu</h3>

<p>Kuten aiemmin mainittiin, story point <a href="/osa2#suhteelliseen-kokoon-perustuva-estimointi">ei vastaa mitään aikaan sidottua työmäärää</a>. Kukin tiimi määrittelee itse sen mitä story point tiimille tarkoittaa. Usein määritelmä perustuu jonkin tietyn user storyn oletettuun työmäärään, tiimi voi esim. määritellä että storyn <em>käyttäjä lisää tuotteen ostoskoriin</em> koko on yksi story point. Tämän takia taas eri kehitystiimien velositeetit eivät ole ollenkaan vertailukelpoisia, poikkeuksena tilanteet, joissa tiimit työskentelevät yhteisen backlogin parissa ja hoitavat estimoinnin yhdessä.</p>

<h2 id="burndown--ja-burnup-kaaviot">Burndown- ja burnup-kaaviot</h2>

<p>Ketterän projektin etenemistä kuvataan joskus <em>release burndown</em> -kaavion avulla. 
Aika etenee kaavion x-akselilla sprintti kerrallaan, y-akselilla on jäljellä olevan työn määrä story pointteina mitattuna:</p>

<p><img src="http://localhost:4000/images/2-13.png" alt="" height="350px" /></p>

<p>Ketterässä projektissa vaatimukset saattavat muuttua kehitystyön aikana, siksi jäljellä olevan työn määrä ei aina vähene. Joskus käytetäänkin <em>burn up</em> -kaavioita, joka tuo selkeämmin esiin kesken projektin etenemisen tapahtuvan työmäärän kasvun:</p>

<p><img src="http://localhost:4000/images/2-14.png" alt="" height="350px" /></p>

<h2 id="julkaisun-suunnittelu-ja-tuotteen-roadmap">Julkaisun suunnittelu ja tuotteen roadmap</h2>

<p>Product backlog siis listaa järjestelmän vaatimuksia kuvaavat user storyt prioriteettijärjestyksessä. Prioriteetin määrittelee useimmiten storyjen asiakkaalle tuova arvo. Kehitystiimi toteuttaa storyja sprintti kerrallaan, valiten kuhunkin sprinttiin joukon sillä hetkellä korkeimman prioriteetin omaavia storyjä.</p>

<p>Ohjelmistoja kehitettäessä tarvitaan usein pelkkää backlogia ja yksittäisiä sprinttejä korkeammalla tasolla olevaa näkymää projektin aikataulutukseen ja kehitystyön suuntaamiseen. Syitä tälle on monia. 
Sovelluksilla saattaa esimerkiksi olla erilaisia deadlineja, joihin mennessä tiettyjen ominaisuuksien on pakko olla valmiina. Joissain tilanteissa taas sovelluksen versioita halutaan julkaista tasaisin väliajoin, esimerkiksi 4 kuukauden välein.</p>

<p>Tällaistä yksittäisiä sprinttejä pidemmän aikavälin suunnittelun tekemistä nimitetään usein <em>julkaisun suunnitteluksi</em> (engl. release planning). Julkaisun suunnittelussa mietitään yleensä user storyjä yleisemmällä tasolla, mitä isompia toiminnallisia kokonaisuuksia kuhunkin julkaisuun tai etappiin (engl. milestone) halutaan mukaan. Etapit eli milestonet taas koostuvat tyypillisesti useammasta sprintistä.</p>

<p>Voidaankin ajatella, että julkaisun suunnittelussa backlogin sisältö jaetaan karkeasti isompiin lohkoihin, joihin sijoitetaan ne user storyt, joiden ajatellaan suunnitteluhetkellä sisältyvän kyseiseen milestoneen:</p>

<p><img src="http://localhost:4000/images/2-10.png" alt="" /></p>

<p>Eri milestonet saattavat olla ajallisesti saman pituisia, eli ne voivat koostua vakiomäärästä sprinttejä. Kaikissa tilanteissa tämäkään ole tarkoituksenmukaista, ja voi olla mielekästä että milestonejen pituus vaihtelee.</p>

<p>Kullakin milestonella voi olla oma korkeamman tason tavoitteensa, esim.:</p>

<ul>
  <li>milestone/release 1: verkkokaupan perustoiminnallisuus</li>
  <li>milestone/release 2: tuotteiden arvostelu ja arvosteluihin perustuva suosittelu</li>
  <li>milestone/release 3: käyttäjien ostoshistoriaan liittyvä tuotteiden suosittelu</li>
</ul>

<p>Näin ohjelmiston isojen linjojen suunniteltu eteneminen on huomattavasti helpompi kommunikoida ohjelmiston sidosryhmille kuin jos verrataan pelkän product backlogin käyttämistä kommunikaation välineenä.</p>

<p>Ketterän hengen mukaan milestonejen sisältö voi kuitenkin elää, ja mitä kauempana olevasta tulevaisuudesta on kyse, sitä spekulatiivisempi julkaisusuunnitelman sisältö on. Julkaisusuunnitelmaa nimitetään usein myös tuotteen <a href="https://www.romanpichler.com/blog/product-roadmap-vs-release-plan/">roadmapiksi</a>.</p>

<h2 id="user-story-mapping">User story mapping</h2>

<p>Product backlogin hienoisena hankaluutena on, että sovelluksen kehityksen suuret linjat eivät tule siitä kunnolla esille.  <a href="https://www.jpattonassociates.com/user-story-mapping/">User story mapping</a> on viime aikoina huomiota saanut tekniikka, joka tarjoaa product backlogin “yksiulotteista” näkymää paremman työkalun sovelluksen julkaisun suunnitteluun.</p>

<p>Tekniikka jakaa user storyt sovelluksen eri toiminnallisten kokonaisuuksien alle omiksi sarakkeikseen tärkeysjärjestykseen. Seuraavassa esimerkkinä verkkokaupan <em>story map</em>, mikä jaottelee user storyt sen mukaan liittyvätkö ne tuotteiden etsimiseen (product search), yksittäisen tuotteen näkymään (product page) vai ostoksen tekemiseen (checkout):</p>

<p><img src="http://localhost:4000/images/2-15.png" alt="" height="400px" /></p>

<p>Story mapin rivit ovat taas loogisia kokonaisuuksia, joista kustakin muodostuu sovellukseen oma milestone tai vaikkapa yhdessä sprintissä kehitettävä mielekäs kokonaisuus.</p>

<h2 id="kannattaako-estimointi">Kannattaako estimointi?</h2>

<p>User storyjen viemän työmäärän arvioimiseen on siis kaksi motivaatiota:</p>
<ul>
  <li>auttaa asiakasta priorisoinnissa</li>
  <li>mahdollistaa koko projektin tai tiettyjä milestonejen viemän ajan ja täten myös kustannuksen arviointi</li>
</ul>

<p>Story point -pohjainen suhteellinen estimointi on saavuttanut vankan aseman ketterän ohjelmistokehityksen kaanonissa. Scrum guide mainitsee että backlogilla olevat vaatimukset ovat estimoituja, samoin kuten monet parhaat käytänteet kuten DEEP.</p>

<p>Viime vuosina syntynyt <a href="https://twitter.com/search?q=%23noestimates">#NoEstimates</a>-liike on kuitenkin ruvennut kyseenalaistamaan story point -perustaista estimointitapaa ja pitää siitä saavutettuja hyötyjä liian vähäisinä verrattuna estimointiin käytettyyn aikaan ja vaivaan. 
#NoEstimates-liike <a href="https://plan.io/blog/noestimates-6-software-experts-give-their-view/">ei missään tapauksessa kiistä</a> etteikö työmääräarvioista olisi hyötyä, tarkoituksena onkin saada ihmiset ajattelemaan, missä tilanteissa estimointi on järkevää sekä nostaa esiin vaihtoehtoisista tapoja estimoinnin tekoon.</p>

<p>Eräs jo <a href="https://ronjeffries.com/xprog/articles/jatrtsmetric/">vuosia käytössä</a> ollut menetelmä on story point -perustaisen estimoinnin sijaan arvioida kehitystiimin velositeetti laskemalla kussakin sprintissä valmistuneiden user storyjen <em>lukumäärä</em>. Monien <a href="http://blog.karhatsu.com/2013/08/from-hour-estimates-gradually-to.html">kokemuksen</a> mukaan menetelmä toimii varsin hyvin, erityisesti jos storyt ovat riittävän tasakokoisia.</p>

<h2 id="sprintin-suunnittelu">Sprintin suunnittelu</h2>

<p>Kertauksena <a href="/osa1#sprintin-suunnittelu">viime viikolta</a>, Scrum määrittelee pidettäväksi ennen jokaista sprinttiä suunnittelupalaverin. Palaverin primäärisenä tavoitteena on selvittää, <em>mitä user storyjä sprintiin</em> valitaan toteutettavaksi.</p>

<p>Sprintin suunnittelun lähtökohtana on sopivassa tilassa oleva, eli DEEP product backlog. Backlog on siis priorisoitu, estimoitu, ja korkeimman prioriteetin omaavat user storyt tarpeeksi pieniä sekä product ownerin hyvin ymmärtämiä.</p>

<p>Sprintin suunnittelussa product owner varmistaa, että kehitystiimi ymmärtää hyvin product backlogin kärkipäässä olevat user storyt. Tiimi valitsee tehtäväksi niin monta backlogin storyistä kuin se arvioi kykenevänsä sprintin aikana toteuttamaan definition of donen määrittelemällä laatutasolla.</p>

<h2 id="sprintin-tavoite">Sprintin tavoite</h2>

<p>Scrum guide kehottaa että suunnittelun yhteydessä määritellään <em>sprintin tavoite</em> (engl. sprint goal), jolla tarkoitetaan lyhyttä, yhden tai kahden lauseen kuvausta siitä, mitä tiimi on aikeissa sprintin aikana tehdä.</p>

<p>Scrumin kehittäjä Ken Schwaber mainitsee 2002 kirjoitetussa kirjassaan asettavansa usein ensimmäisen sprintin tavoitteeksi: <em>demonstrate a key piece of user functionality on the selected technology</em>.</p>

<p>Esimerkiksi verkkokauppaa kehitettäessä seuraavien sprinttien tavoitteita voisivat olla:</p>
<ul>
  <li>Ostoskorin perustoiminnallisuus: tuotteiden lisäys ja poisto</li>
  <li>Ostosten maksaminen ja toimitustavan valinta</li>
</ul>

<p>Sprintin tavoite toimii tiimin ulkopuoliselle nopeana kuvauksena siitä, mitä tiimi on kuluvan sprintin aikana tekemässä. Vaikka sama asia periaatteessa selviää myös katsomalla, mitkä user storyt ovat tiimillä työn alla, on geneerisemmässä muodossa oleva lyhyempi kuvaus parempi monille ohjelmiston sidosryhmille, kuten firman johdolle, joita ei kiinnosta seurata tapahtumia yksittäisten storyjen tarkkuudella.</p>

<p>Sprintin onnistumista tarkastellaan yleensä suhteessa sprintin tavoitteeseen, eli vaikka sprintissä jäisikin yksittäisiä user storyjä toteuttamatta, voidaan sprintti todeta onnistuneeksi jos toteutettu toiminnallisuus kattaa sprintin tavoitteiden oleelliset osat.</p>

<h2 id="sprintissä-toteutettavien-user-storyjen-määrä">Sprintissä toteutettavien user storyjen määrä</h2>

<p>Kehitystiimi siis päättää kuinka monta user storyä sprinttiin otetaan toteutettavaksi. Pääperiaate on valita “sopiva määrä” backlogin korkeimmalle priorisoituja user storyjä ja siirtää ne <em>sprint backlogiin</em>.</p>

<p><img src="http://localhost:4000/images/2-16.png" alt="" height="350px" /></p>

<p>Tapoja päättää sprinttiin otettavien storyjen määrä on <a href="https://www.infoq.com/minibooks/scrum-xp-from-the-trenches-2/">useita</a>:</p>
<ul>
  <li>jos storyt ovat estimoituja ja tiimin velositeetti tunnetaan, otetaan sprinttiin velositeetin verran storyjä</li>
  <li>jos estimaatteja ei ole ja/tai velositeettiä ei tunneta, otetaan niin monta korkeimman priotiteetin storyä, kuin mihin kaikki tiimiläiset tuntevat voivansa sitoutua</li>
  <li>edellisten yhdistelmä, eli vaikka velositeetti ja estimaatit olisivat tiedossa, niin käytetään myös harkintaa sen suhteen onko velositeetin avulla valittu määrä tiimiläisistä sopivan tuntuinen</li>
</ul>

<p>Käytetään mitä valintaperiaatetta tahansa, on joka tapauksessa oleellista että toteutettavaksi valitaan vain sellainen määrä storyjä, jotka tiimi kokee voivansa toteuttaa kunnolla, eli definition of donen määrittelemällä laatutasolla.</p>

<h2 id="sprintissä-toteutettavien-user-storyjen-valinta">Sprintissä toteutettavien user storyjen valinta</h2>

<p>Oletusarvoisesti sprinttiin siis otetaan joukko backlogin kärjessä olevia user storyjä:</p>

<p><img src="http://localhost:4000/images/2-17.png" alt="" height="220px" /></p>

<p>Product ownerilla on kuitenkin mahdollisuuksia vaikuttaa sprinttiin mukaan otettaviin storyihin tekemällä <em>uudelleenpriorisointia</em>.</p>

<p>Entä jos product owner haluaa storyn D mukaan sprinttiin? Product owner nostaa D:n prioriteettia, C tippuu pois sprinttiin valittavien user storyjen joukosta:</p>

<p><img src="http://localhost:4000/images/2-18.png" alt="" height="250px" /></p>

<p>Entä jos product owner haluaa sprinttiin mukaan kaikki user storyt A-D? Jostain on luovuttava: product owner pienentää user storyn A määrittelemää toiminnallisuutta, kehitystiimi estimoi pienennetyn A:n ja nyt A-D mahtuvat sprinttiin:</p>

<p><img src="http://localhost:4000/images/2-19.png" alt="" height="215px" /></p>

<p>Entä jos A:n toiminnallisuutta ei saa karsia ja product owner silti haluaa A-D:n mukaan sprinttiin?
Ratkaisu tähän on jakaa user story A kahteen pienempään osaan A1:n ja A2:n. A1 sisältää A:n tärkeimmät piirteet ja otetaan mukaan sprinttiin, A2 saa alemman prioriteetin, ja jää sprintin ulkopuolelle:</p>

<p><img src="http://localhost:4000/images/2-20.png" alt="" height="250px" /></p>

<h2 id="user-storyjen-jakaminen">User storyjen jakaminen</h2>

<p>User storyjen jakaminen pienemmiksi ei ole aloittelijalle, eikä aina ammattilaisellekaan helppoa.</p>

<p>Jo aiemmin mainittu <a href="/osa2#hyvän-user-storyn-kriteerit">INVEST</a>-periaate antaa kuusi kriteeriä hyvälle, toteutettavaksi sopivalle user storylle, ja nämä kriteerit kannattaa pitää myös jakaessa storyjä pienemmiksi. Eräs melko ilmeinen tapa olisi jakaa storyjä ohjelmiston arkkitehtuurikerrosten mukaan, eli esim. <em>lisää tuote ostoskoriin</em> jaettaisiin seuraaviin storyihin:</p>

<ul>
  <li>selaimessa toimivaan käyttöliittymään nappi ostoksen lisäämiseksi</li>
  <li>palvelimella olevaan sovelluslogiikkaan mekanismi ostoskorin päivittämiselle</li>
  <li>tietokantaan taulu ostoskorin esittämiseen</li>
</ul>

<p>Tällainen jako ei kuitenkaan ole hyvä. Näin jaetut storyt eivät ole asiakkaalle arvoa tuottavia (valuable) eivätkä toisistaan riippumattomia (independent), eli jos storyista toteutettaisiin vaikkapa ensimmäinen ja toinen, oltaisiin vielä riippuvaisia kolmannesta storysta ennen kuin toiminnallisuus olisi mielekäs.</p>

<p>Seuraavassa muutamia erilaisia tapoja storyjen jakamiseen <a href="http://www.richardlawrence.info/2009/10/28/patterns-for-splitting-user- stories/">Richard Lawrencen</a> inspiroimana.</p>

<h4 id="pattern-1-workflow-steps">Pattern 1: workflow steps</h4>

<p>Tarkastellaan Flamman kaltaista sovellusta jonka avulla voi mm. julkaista artikkeleja yrityksen web-sivulle. Eräs sovelluksen user storyista on seuraava:</p>

<p><em>As a content manager, I can publish a news story to the corporate website.</em></p>

<p>Artikkelien julkaisu sovellusta käyttävässä yrityksessä on monivaiheinen prosessi, kukin artikkeli kulkee usean työvaiheen (workflow) läpi, artikkelit mm. tarkastetaan kielellisesti (editor review) ja lainopillisesti (legal review), ja näitä varten artikkelit julkaistaan ensin ns. <em>staging</em>-ympäristöön.</p>

<p>Eräs tapa pilkkoa alkuperäinen story onkin jakaa se useampaan osaan eri työvaiheiden mukaan:</p>

<ul>
  <li><em>… I can publish a news story directly to the corporate website</em></li>
  <li><em>… I can publish a news story with editor review on a staging site</em></li>
  <li><em>… I can publish a news story with legal review on a staging site</em></li>
  <li><em>… I can view a news story on a staging site</em></li>
  <li><em>… I can publish a news story from the staging site to production</em></li>
</ul>

<p>Vaikka ensimmäinen story ei vielä yksistään tarjoa tukea kaikille työvaiheille, riittää sen toteuttaminen jo ehkä ominaisuuden käyttöönottoon, muut työvaiheet (editointi ja lainopillisuuden tarkastus) voidaan aluksi hoitaa järjestelmän ulkopuolella esim. emailitse. Myöhemmissä sprinteissä voidaan sitten toiminnallisuutta tarpeen mukaan laajentaa toteuttamalla muut storyt.</p>

<h4 id="pattern-2-business-rule-variations">Pattern 2: business rule variations</h4>

<p>Story joka sisältää monenlaisia kompleksisia ehtoja (business rule), esim.</p>

<p><em>As a user, I can search for flights with flexible dates.</em></p>

<p>kannattaa jakaa siten että jokainen näistä ehdoista eritellään omaksi storykseen:</p>

<ul>
  <li><em>… as “between dates x and y”</em></li>
  <li><em>… as “a weekend in December”</em></li>
  <li><em>… as “± n days of dates x and y”</em></li>
</ul>

<h4 id="pattern-3-simplecomplex">Pattern 3: simple/complex</h4>

<p>Hieman samanlainen kuin edellinen tapa on jakaa monimutkainen user story siten, että siitä erotetaan yksinkertainen, mutta jo itsessään hyödyllinen story, eräänlainen “minimal viable product” , ja muodostetaan joukko storeja, jotka lisäävät sen määrittelemää perustoiminnallisuutta.</p>

<p>Esimerkiksi joustavaa lentojen hakua kuvaava story</p>

<p><em>As a user, I can search for flights between two destinations</em></p>

<p>voidaan jakaa seuraavasti</p>

<ul>
  <li><em>… when only direct flights used</em></li>
  <li><em>… specifying a max number of stops</em></li>
  <li><em>… including nearby airports</em></li>
  <li><em>… using flexible dates</em></li>
</ul>

<h4 id="pattern-4-major-effort">Pattern 4: major effort</h4>

<p>Joskus hyvä jakoperuste on toteuttaa story toimimaan ensin yhden esimerkkitapauksen kanssa ja yleistää se omana storynaan. Esimerkiksi luottokorttimaksamista koskeva story</p>

<p><em>As a user, I can pay for my flight with VISA, MasterCard, Diners Club, or American Expres.</em></p>

<p>voitaisiin jakaa kahtia, missä ensimmäisessä storyssa vasta hoidettaisiin yksi luottokorttityyppi, ja seuraava story yleistäisi toiminnan kaikkiin kortteihin:</p>

<ul>
  <li><em>… I can pay with VISA</em></li>
  <li><em>… I can pay with all four credit card types (VISA, MC, DC, AMEX) (given one card type already implemented)</em></li>
</ul>

<h4 id="pattern-5-data-entry-methods">Pattern 5: data entry methods</h4>

<p>Hyvä tapa storyen jakoon on myöskin muodostaa ensin versio, jossa on yksinkertainen käyttöliittymä ja laajentaa sitä omana storynaan. User story</p>

<p><em>As a user, I can search for flights between two destinations</em></p>

<p>jakaantuukin helposti kahteen esim. seuraavasti</p>

<ul>
  <li><em>… using simple date input</em></li>
  <li><em>… with a fancy calendar UI</em></li>
</ul>

<h4 id="pattern-6-defer-performance">Pattern 6: Defer Performance</h4>

<p>Joissain tapauksissa vastaava jako voidaan tehdä suorituskyvyn suhteen, eli aluksi tehdään perusversio ja laajentava story optimoi suorituskykyä. User story</p>

<p><em>As a user, I can search for flights between two destinations</em></p>

<p>siis jakaantuu kahtia seuraavasti:</p>

<ul>
  <li><em>… slow—just get it done, show a “searching” animation</em></li>
  <li><em>… in under 5 seconds</em></li>
</ul>

<h4 id="pattern-7-operations">Pattern 7: Operations</h4>

<p>Eräs yleisimpiä tapoja jakamiseen on eritellä storyyn sisältyvät toiminnot omiksi storyikseen.</p>

<p>Käyttäjän hallinnointia kuvaava story</p>

<p><em>As a user, I can manage my account</em></p>

<p>jakaantuu  mukavasti moneen osaan</p>

<ul>
  <li><em>… I can sign up for an account</em></li>
  <li><em>… I can edit my account settings</em></li>
  <li><em>… I can cancel my account</em></li>
</ul>

<h4 id="pattern-8-break-out-a-spike">Pattern 8: Break Out a Spike</h4>

<p>On monia tilanteita, joissa storyn kokoa on todella vaikeaa arvioida etukäteen. Story voi joko olla vaatimuksiltaan epäselvä, eli ei oikein tiedetä vielä mitä halutaan, tai story saattaa sisältää jonkin toteutusteknisesti riskialttiin osan. Joskus storyn sisältämä epävarmuus ei poistu mitenkään muuten kuin tekemällä kokeellinen toteutus, jonka avulla tutkitaan teknisiä riskejä tai selvitellään käyttäjän tahtotilaa.</p>

<p>Tällaisestä eksperimentaalisesta toteutuksesta käytetään nimitystä <a href="https://www.jamesshore.com/Agile-Book/spike_solutions.html">spike solution</a>, ja useimmiten sellaisen toteuttamiseen annetaan jokin rajattu määrä aikaa, esim. 2 päivää.</p>

<p>Jos tiimi ei ole toteuttanut koskaan luottokorttimaksuun liittyvää toiminnallisuutta, user storysta</p>

<p><em>As a user, I can pay by credit card</em></p>

<p>kannattaa eriyttää aikarajattu eksperimentti joka suoritetaan aiemmassa sprintissä. Tämän jälkeen toivon mukaan varsinaisen toiminnallisuuden toteuttava story osataan estimoida paremmin:</p>

<ul>
  <li><em>Investigate credit card processing</em></li>
  <li><em>Implement credit card processing</em></li>
</ul>

<p>Aiemmin tässä osassa puhuimme <a href="http://localhost:4000/osa2#vaatimusma%CC%88a%CC%88rittely-2010-luvulla">Lean-startup</a>-menetelmästä, jossa uusien ideoiden toimivuutta kokeillaan A/B-testauksella, eli ideasta toteutetaan minimal viable product (MVP) eli minimalistinen versio, joka annetaan käyttöön osalle järjestelmän käyttäjistä. Jos uusi idea vaikuttaa toimivalta, toteutetaan se kunnolla ja korvataan sillä alkuperäinen toiminnallisuus. A/B-testaus onkin idealtaan hyvin samankaltainen kuin <em>spike</em>-solution, eli A/B-testissä rakennettavan MVP-version avulla selvitetään jonkin idean toimivuus ja vasta sen jälkeen toteutetaan toiminnallisuus kokonaisessa laajuudessaan.</p>

<p>User storyjen jakamisesta on monia etuja. Storyjä jaettaessa huomataan usein, että alkuperäinen iso story eli epiikki, kuvaa itse asiassa paljon laajemman toiminnallisuuden kuin mille on tarvetta, eli sovelluksesta saadaan storyjen jakamisen avulla mahdollisesti karsittua pois paljon turhaa toiminnallisuutta. Storyjen pienuus kasvattaa myös ohjelmistokehityksen ennustettavuutta. Mitä pienempiä storyt ovat, sitä helpompi ne on estimoida ja sitä varmemmin ne saadaan toteutettua yhden sprintin aikana, ja näin tiimin velositeetista tulee paremmin ennustettava.</p>

<h2 id="sprintin-suunnittelun-toinen-tavoite">Sprintin suunnittelun toinen tavoite</h2>

<p>Sprintin suunnittelun yhteydessä sprinttiin valituille user storyille tehdään yleensä myös riittävä määrä teknistä suunnittelua, eli hahmotellaan, <em>miten</em> storyt saadaan toteutettua. Suunnitellaan komponentteja ja rajapintoja karkealla tasolla sekä huomioidaan user storyjen aiheuttamat muutokset olemassa olevaan osaan sovelluksesta.</p>

<p>Suunnittelun yhteydessä on usein tapana pilkkoa kukin user story teknisen tason tehtäviksi (engl. task) jotka on toteutettava, jotta user story saadaan valmiiksi.</p>

<p>Esimerkiksi story <em>tuotteen lisääminen ostoskoriin</em> voitaisiin pilkkoa seuraaviin teknisen tason taskeihin:</p>
<ul>
  <li>tarvitaan sessio, joka muistaa asiakkaan</li>
  <li>domain-olio ostoskorin ja ostoksen esittämiseen</li>
  <li>laajennus tietokantaskeemaan</li>
  <li>html-näkymää päivitettävä tarvittavilla painikkeilla</li>
  <li>kontrolleri painikkeiden käsittelyyn</li>
  <li>yksikkötestit kontrollerille ja domain-olioille</li>
  <li>hyväksymätestien automatisointi</li>
</ul>

<h2 id="sprint-backlog">Sprint backlog</h2>

<p>Sprintin tehtävälista eli <em>sprint backlog</em> koostuu sprintiin valituista user storyista ja niihin liittyvistä teknisen tason tehtävistä eli taskeista. Sprint backlog on ensisijaisesti kehitystiimin työväline ja tiimi päättää scrum masterin avustuksella sen miten se backloginsa organisoi.</p>

<p>Sprint backlog organisoidaan usein taulukkomaiseksi <em>taskboardiksi</em>, jossa on yksi rivi kutakin sprinttiin valittua user storya kohti. Storyyn liittyvät taskit kulkevat vasemmalta oikealle niiden statusta kuvaavien sarakkeiden <em>not started, in progress, done</em> kautta:</p>

<p><img src="http://localhost:4000/images/2-21.png" alt="" height="400px" /></p>

<p>Kaikkia storyyn liittyviä taskeja ei sprintin suunnittelun aikana yleensä löydetä ja uusia taskeja lisätään tarvittaessa sprintin edetessä.</p>

<p>Nykyinen paras käytäntö on käyttää fyysisiä taskboardeja, user storyt ovat esimerkiksi pahvikortteja ja taskit kirjoitetaan post it -lapuille.</p>

<p><img src="http://localhost:4000/images/2-23.jpg" alt="" /></p>

<p>Esimerkin taskboardissa on edellisestä poiketen myös sarake <em>blocked</em>, joka kuvaa niitä taskeja, joiden toteuttaminen on syystä tai toisesta keskeytynyt jonkin esteen takia. Task board voikin sisältää mitä tahansa sarakkeita. Scrum ei anna mitään ohjeistoa sprint backlogin muodostamiseen, pääasia onkin että tiimi muokkaa taskboardinsa omia tavoitteitaan tukevaksi. On myös melko tyypillistä että tiimi muokkaa taskboardia projektin kuluessa huomatessaan että olemassa olevan taskboardin rakenne ei ole enää optimaalinen tiimin työskentelylle.</p>

<h2 id="sprintin-työmääräarviot-ja-burndown">Sprintin työmääräarviot ja burndown</h2>

<p><a href="https://scrumguides.org/scrum-guide.html#artifacts-sprintbacklog">Scrum guiden</a> mukaan tiimin tulee seurata sprintin aikana kuinka paljon sprintissä on vielä töitä jäljellä. Eräs tapa toteuttaa sprintinaikainen työmäärän seuranta on estimoida sprintissä olevien taskien työmäärää. Useiden <a href="https://www.mountaingoatsoftware.com/blog/why-agile-teams-should-estimate-at-two-different-levels">asiantuntijoiden</a> mukaan sprinttiin kuuluvat taskit tulisi estimoida niiden vaatiman <em>työtuntimäärän</em> mukaan, toisin kuin user storyt, jotka estimoidaan abstraktin aikamääreen eli story pointin tarkkuudella.</p>

<p>Taskien estimaatit tulee pitää ajan tasalla, eli jokaisen taskin jäljellä olevan työn määrä arvioidaan esim. päivittäisessä scrum-palaverissa eli daily scrumeissa.</p>

<p>Jäljellä olevaa työmäärää (tunteina mitattuna) voidaan visualisoida sprintin etenemistä kuvaavalla burndown-käyrällä:</p>

<p><img src="http://localhost:4000/images/2-22.png" alt="" /></p>

<p>Työmääräarvio voi myös nousta kesken sprintin jos kesken sprintin identifioidaan uusia taskeja tai jokin task huomataan monimutkaisemmaksi kuin alunperin ajateltiin. Oleellista on, että taskien työmääräarviot ovat <em>arvioita niihin vielä tarvittavasta työmäärästä</em>. Scrumissa ei seurata millään tavalla taskeihin <em>käytettyä</em> työmäärää, eli vaikka johonkin taskiin olisi käytetty 5 tuntia, sitä ei merkata mihinkään eikä sitä suoraan vähennetä työmääräarviosta vaan tehdään <em>uusi työmääräarvio</em> siitä, paljonko vielä ajatellaan tarvittavan aikaa, jotta story saadaan valmiiksi.</p>

<h3 id="sprintin-taskboardin-formaatti">Sprintin taskboardin formaatti</h3>

<p>Yleinen konsensus on, että ainakin Sprintin hallintaan manuaalinen postit-lappuja hyödyntävä taskboard on käytettävyydeltään ja informatiivisuudeltaan ylivertainen.</p>

<p>Usein toki käytetään elektronisia versioita taskboardista, joskus siihen pakottavat yritysten käytänteet, joskus taas tiimiläisten työskentelytapa ja paikka, esimerkiksi etätiimin kannalta elektroninen taskboard voi olla ainoa toimiva ratkaisu.</p>

<p>Erilaisia ratkaisuja elektronisen backlogin ja taskboardin muodostamiseen on lukemattomia. Voidaan käyttää jotain yleishyödyllistä sovellusta, esimerkiksi exceliä tai google driveä. Github projects tarjoaa nykyään varsin käyttökelpoisen taskboard-näkymän Githubin issueihin. On myös olemassa suuri joukko enemmän tai vähemmän käyttökelpoisia sovelluksia, jotka on tehty varta vasten ketterien projektien hallintaan, muutamana esimerkkinä mainittakoon JIRA, Asana, Trello, Pivotal Tracker, trac ja bugzilla.</p>

<p>Taulukkolaskentaohjelmat toimivat kohtuullisen hyvin elektronisena taskboardina. Taulukkolaskentaa käyttäessä sprintin jokaiselle päivälle on oma sarake, johon merkitään kunkin päivän alussa estimaatti taskien jäljellä olevasta työmäärästä (tunteina):</p>

<p><img src="http://localhost:4000/images/2-24.png" alt="" height="400px" /></p>

<p>Näin sprintin burndown-kaavion piirto on helppo automatisoida. Erään ohjelmistotuotantoprojektin product- ja sprintbacklogit <a href="https://docs.google.com/spreadsheets/d/13RzIZI2NFFuV0zdRjrrfoC-CrootK8AZNuHS571Wlxo/edit?usp=sharing">täällä</a>.</p>

<p>Taskboard ja mahdollisesti käytössä oleva burndown-käyrä tuovat selkeästi esille sprintin etenemisen asteen ja onkin suositeltavaa, että ne ovat kaikkien tiimiläisten ja projektin sidosryhmäläisten nähtävillä. Elektronisia taskboardeja käytettäessä on aina se riski, että ne eivät säteile informaatiota yhtä hyvin kuin seinällä oleva manuaalinen taskboard. Näin ketterän kehityksen kannalta elintärkeä läpinäkyvyyden periaate saattaa vaarantua.</p>

<h3 id="kannattako-sprintin-sisäinen-työmäärän-estimointi">Kannattako sprintin sisäinen työmäärän estimointi</h3>

<p>On hieman kiistanalaista, kannattaako storyihin liittyvien taskien työmäärää estimoida. Syksyllä 2019 julkaistu kirja <a href="http://scrumbook.org/value-stream/information-radiator/sprint-burndown-chart.html">A Scrum book</a> ei suosittele taskien tasolla pidettävää työmääräarviota, vaan kehottaa seuraamaan sprinttienkin aikana ainoastaan sitä <em>kuinka monen story pointin verran user storyja on saatu valmiiksi</em>.</p>

<p>Neuvo onkin varsin viisas: on nimittäin mahdollista, että tiimi saa sprintissä valmiiksi lähes kaikki taskit saamatta kuitenkaan yhtäkään storya täysin valmiiksi, eli burn down voi näyttää melko hyvältä mutta asiakkaan saama arvo on lopulta nolla.</p>

<p>Fyysistä taskboardia käytettäessä sprintin työmäärän estimoinnin ja burndown-käyrän piirtämisen sijaan erittäin simppeli tapa sprintin etenemisen seurantaan on laskea, tai jopa ainoastaan visuaalisesti katsoa taskboardilta, mikä on jo valmiiden ja vielä valmistumattomien sprinttiin kuuluvien taskien lukumäärä.</p>

<h2 id="yhtäaikaa-tehtävän-työn-rajoittaminen">Yhtäaikaa tehtävän työn rajoittaminen</h2>

<p>Yhtä aikaa työn alla olevien taskien suuri määrä voikin koitua scrumissa ongelmaksi, sillä riski sille, että sprintin päätyttyä on paljon osittain valmiita user storyja kasvaa. Voikin olla mielekästä rajoittaa yhtä aikaa tekemisen alla olevien töiden määrää asettamalla <em>work in progress (eli WIP)</em> -rajoituksia. WIP-rajoitukset on lainattu Kanban-menetelmästä, jota käsittelemme tarkemmin <a href="/osa5#kanban">osassa 5</a>. Scrumin ja Kanbanin yhdistelmää kutsutaan usein nimellä <a href="https://www.cs.helsinki.fi/u/mluukkai/ohtu/ilves-kandi.pdf">Scrumban</a>. Scrumbanissa on tosin muitakin Kanbanista lainattuja elementtejä kuin WIP-rajoitukset.</p>

<p>WIP-rajoituksia voidaan soveltaa monella tavalla, esim. rajaamalla tietyssä task boardin vaiheessa olevien töiden määrää:</p>

<p><img src="http://localhost:4000/images/2-25.png" alt="" height="350px" /></p>

<p>Kuvan esimerkissä rajoitteet on ilmaistu työvaiheita kuvaavien sarakkeiden otsikoihin merkittynä numerona. Esimrkiksi numero 3 sarakkeessa <em>development</em> määrää, että toteutusvaiheessa ei saa olla yhtä aikaa enempää kuin kolme taskia, vastaavasti 2 sarakkeessa <em>testing</em> rajaa kerrallaan testauksen alla olevien taskiksi määräksi kaksi.</p>

<h2 id="lean-waste-ja-scrumban">Lean waste ja Scrumban</h2>

<p>Yhtäaikaa tehtävän työn määrää kontrolloivien WIP- eli Work in progress -rajoitusten idea on siis peräisin Kanban-menetelmästä. Kanban-menetelmä taas on eräs keskeisimmistä Lean-ajattelun työkaluista.</p>

<p>Lean-ajattelun taustalla on idea hukan (engl. waste, jap. muda) eli arvoa tuottamattomien asioiden eliminointi organisaatioiden toiminnasta. Lean-ajattelu on peräisin jo kymmeniä vuosia vanhasta <a href="https://global.toyota/en/company/vision-and-philosophy/production-system/">Toyota Production Systemistä</a>.</p>

<p>Lean tunnistaa usean tyyppistä hukkaa (lean waste), näiden joukossa ovat esimerkiksi osittain tehty työ (partially done work), välivarastointi ja turha odottaminen. Ohjelmistotuotannon kontekstiin sovellettuna työvaiheet, jotka eivät ole vielä definition of donen mielessä valmiina edustavat leanin mukaista hukkaa. Esimerkiksi testaamista odottavien toiminnallisuuksien (user storyjen) katsotaan olevan “välivarastoituna”, samoin jo testatut mutta tuotantoon viemistä vielä odottavat toiminnallisuudet ovat “välivarastossa”.</p>

<p>Asiakkaalle toiminnallisuudet alkavat tuottaa arvoa vasta kun ne saadaan käyttöön, siinä vaiheessa kun toiminnallisuudet ovat työn alla, ne aiheuttavat ainoastaan kustannuksia ja muodostavat riskin.</p>

<p>Kanban- ja Scrumban-menetelmissä WIP-rajoitteilla rajataan useimmiten yhtä aikaa työn alla olevien user storyjen määrää. Kanbanissa ja Scrumbanissa ei yleensä ole olemassa Scrumin sprintin kaltaista kehitystyötä rytmittävää käsitettä vaan saatetaan noudattaa periaatetta, missä tiimi tekee yhden user storyn kerrallaan valmiiksi, demoaa sen asiakkaalle ja valitsee product backlogista seuraavan storyn työn alle.</p>

<p>Joissain tapauksissa asiakastapaamiset ja valmiiden storyjen esittely voi Kanbanissa ja Scrumbanissa tapahtua sovitun aikataulun, esimerkiksi 2 viikon välein vaikka itse kehitystyö ei noudattaisi sprinttejä vaan etenisi story kerrallaan.</p>

<p>WIP-rajoitteita voidaan soveltaa Scrumin yhteydessä monella tapaa. Edellä olleessa esimerkissä rajoitettiin kerrallaan yhdessä työvaiheessa sallittujen taskien määrää. Voi olla mielekästä myös määritellä, kuinka monta taskia yhdellä henkilöllä saa olla yhdellä kertaa työn alla. 
Ehkä paras tapa soveltaa WIP-rajoitteita on rajoittaa kerrallaan työn alla olevien user storyjen määrää. Esimerkiksi <a href="http://scrumbook.org/">Scrum book</a> suosittelee, että työn alla on kerrallaan ainoastaan yksi user story. Näin taataan että arvoa tuottavia kokonaisuuksia “virtaa” sovelluksen käyttäjälle mahdollisimman tasaisesti.</p>

<p>WIP-rajoitteita säädetään usein retrospektiivien yhteydessä jos kehitystyössä havaitaan ongelmia.</p>

<h2 id="ennen-seuraavaa-sprintin-alkua">Ennen seuraavaa sprintin alkua</h2>

<p>Kuten edellisessä osassa <a href="/osa1#sprintin-katselmointi">mainittiin</a>, pidetään sprintin lopussa sprint review eli katselmointi sekä sprintin retrospektiivi. Katselmoinnissa arvioidaan kehitystiimin tekemää työtä. Kesken jääneet tai epäkelvosti toteutetut user storyt siirretään takaisin backlogiin.</p>

<p>Sprintin aikana product backlogiin on ehkä tullut uusia user storyja tai jo olemassa olevia storyjä on muokattu ja uudelleenpriorisoitu. On suositeltavaa että kehitystiimi käyttää pienen määrän aikaa sprintin aikana product backlogin vaatimiin toimiin eli <a href="/osa2#hyva%CC%88-product-backlog-on-deep">backlog groomingiin</a>, esim. uusien user storyjen estimointiin. Jos product backlog on hyvässä kunnossa eli <a href="/osa2#hyva%CC%88-product-backlog-on-deep">DEEP</a> sprintin loppuessa, on jälleen helppo lähteä sprintin suunnitteluun ja uuteen sprinttiin.</p>

<p>Retrospektiivissa taas tiimi itse tarkastelee omaa toimintatapaansa ja identifioi mahdollisia kehityskohteita seuraavaan sprinttiin. Eräs tärkeä tarkastelun kohde retrospektiivissa on sprintin taskboard, tuoko se riittävästi läpinäkyvyyttä sprintin seurantaan, tulisko boardille lisätä näkyviin useampia työvaiheita (esim. testing, releasing, …), jumiutuiko taskeja odottamattomalla tavalla joihinkin työvaiheisiin, tulisiko boardille lisätä WIP-rajoitteita?</p>

  </div>

</article>
      </div>
    </main>

     <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
             Ohjelmistotuotanto avoin yliopisto 2021 
          </li>
          <li>
            <a href="mailto:matti.luukkainen@helsinki.fi">matti.luukkainen@helsinki.fi</a>
          </li>
          <li>
            <a href="https://github.com/mluukkai"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">mluukkai</span></a>

          </li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
           
        </ul>
      </div>

      <div class="footer-col footer-col-3">
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
            <img alt="Creative Commons -lisenssi" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png"
            />
          </a>
          <br/> Materiaali on lisensoitu
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons BY-NC-SA 3.0 -lisenssillä</a>.
      </div>
    </div>

  </div>

</footer>
  
  </body>

</html>
